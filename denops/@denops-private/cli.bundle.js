class DenoStdInternalError extends Error{constructor(e){super(e);this.name="DenoStdInternalError"}}function assert(t,e=""){if(!t)throw new DenoStdInternalError(e)}const{hasOwn}=Object;function get(t,e){if(hasOwn(t,e))return t[e]}function getForce(t,e){const r=get(t,e);return assert(r!=null),r}function isNumber(t){return typeof t=="number"||/^0x[0-9a-f]+$/i.test(String(t))?!0:/^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(String(t))}function hasKey(t,e){let r=t;return e.slice(0,-1).forEach(s=>{r=get(r,s)??{}}),e[e.length-1]in r}function parse(t,{"--":e=!1,alias:r={},boolean:i=!1,default:s={},stopEarly:n=!1,string:o=[],unknown:a=h=>h}={}){const h={bools:{},strings:{},unknownFn:a,allBools:!1};if(i!==void 0)if(typeof i=="boolean")h.allBools=!!i;else{const d=typeof i=="string"?[i]:i;for(const w of d.filter(Boolean))h.bools[w]=!0}const l={};if(r!==void 0)for(const d in r){const w=getForce(r,d);typeof w=="string"?l[d]=[w]:l[d]=w;for(const y of getForce(l,d))l[y]=[d].concat(l[d].filter(E=>y!==E))}if(o!==void 0){const d=typeof o=="string"?[o]:o;for(const w of d.filter(Boolean)){h.strings[w]=!0;const y=get(l,w);if(y)for(const E of y)h.strings[E]=!0}}const c={_:[]};function f(d,w){return h.allBools&&/^--[^=]+$/.test(w)||get(h.bools,d)||!!get(h.strings,d)||!!get(l,d)}function u(d,w,y){let E=d;w.slice(0,-1).forEach(function(T){get(E,T)===void 0&&(E[T]={}),E=get(E,T)});const L=w[w.length-1];get(E,L)===void 0||get(h.bools,L)||typeof get(E,L)=="boolean"?E[L]=y:Array.isArray(get(E,L))?E[L].push(y):E[L]=[get(E,L),y]}function A(d,w,y=void 0){if(y&&h.unknownFn&&!f(d,y)&&h.unknownFn(y,d,w)===!1)return;const E=!get(h.strings,d)&&isNumber(w)?Number(w):w;u(c,d.split("."),E);const L=get(l,d);if(L)for(const T of L)u(c,T.split("."),E)}function _(d){return getForce(l,d).some(w=>typeof get(h.bools,w)=="boolean")}for(const d of Object.keys(h.bools))A(d,s[d]===void 0?!1:s[d]);let b=[];t.includes("--")&&(b=t.slice(t.indexOf("--")+1),t=t.slice(0,t.indexOf("--")));for(let d=0;d<t.length;d++){const w=t[d];if(/^--.+=/.test(w)){const y=w.match(/^--([^=]+)=(.*)$/s);assert(y!=null);const[,E,L]=y;h.bools[E]?A(E,L!=="false",w):A(E,L,w)}else if(/^--no-.+/.test(w)){const y=w.match(/^--no-(.+)/);assert(y!=null),A(y[1],!1,w)}else if(/^--.+/.test(w)){const y=w.match(/^--(.+)/);assert(y!=null);const[,E]=y,L=t[d+1];L!==void 0&&!/^-/.test(L)&&!get(h.bools,E)&&!h.allBools&&(get(l,E)?!_(E):!0)?(A(E,L,w),d++):/^(true|false)$/.test(L)?(A(E,L==="true",w),d++):A(E,get(h.strings,E)?"":!0,w)}else if(/^-[^-]+/.test(w)){const y=w.slice(1,-1).split("");let E=!1;for(let T=0;T<y.length;T++){const g=w.slice(T+2);if(g==="-"){A(y[T],g,w);continue}if(/[A-Za-z]/.test(y[T])&&/=/.test(g)){A(y[T],g.split(/=(.+)/)[1],w),E=!0;break}if(/[A-Za-z]/.test(y[T])&&/-?\d+(\.\d*)?(e-?\d+)?$/.test(g)){A(y[T],g,w),E=!0;break}if(y[T+1]&&y[T+1].match(/\W/)){A(y[T],w.slice(T+2),w),E=!0;break}else A(y[T],get(h.strings,y[T])?"":!0,w)}const[L]=w.slice(-1);!E&&L!=="-"&&(t[d+1]&&!/^(-|--)[^-]/.test(t[d+1])&&!get(h.bools,L)&&(get(l,L)?!_(L):!0)?(A(L,t[d+1],w),d++):t[d+1]&&/^(true|false)$/.test(t[d+1])?(A(L,t[d+1]==="true",w),d++):A(L,get(h.strings,L)?"":!0,w))}else if((!h.unknownFn||h.unknownFn(w)!==!1)&&c._.push(h.strings._??!isNumber(w)?w:Number(w)),n){c._.push(...t.slice(d+1));break}}for(const d of Object.keys(s))if(!hasKey(c,d.split("."))&&(u(c,d.split("."),s[d]),l[d]))for(const w of l[d])u(c,w.split("."),s[d]);if(e){c["--"]=[];for(const d of b)c["--"].push(d)}else for(const d of b)c._.push(d);return c}const mod={parse},osType=(()=>{const{Deno:t}=globalThis;if(typeof t?.build?.os=="string")return t.build.os;const{navigator:e}=globalThis;return e?.appVersion?.includes?.("Win")??!1?"windows":"linux"})(),isWindows=osType==="windows",CHAR_FORWARD_SLASH=47;function assertPath(t){if(typeof t!="string")throw new TypeError(`Path must be a string. Received ${JSON.stringify(t)}`)}function isPosixPathSeparator(t){return t===47}function isPathSeparator(t){return isPosixPathSeparator(t)||t===92}function isWindowsDeviceRoot(t){return t>=97&&t<=122||t>=65&&t<=90}function normalizeString(t,e,r,i){let s="",n=0,o=-1,a=0,h;for(let l=0,c=t.length;l<=c;++l){if(l<c)h=t.charCodeAt(l);else{if(i(h))break;h=CHAR_FORWARD_SLASH}if(i(h)){if(!(o===l-1||a===1))if(o!==l-1&&a===2){if(s.length<2||n!==2||s.charCodeAt(s.length-1)!==46||s.charCodeAt(s.length-2)!==46){if(s.length>2){const f=s.lastIndexOf(r);f===-1?(s="",n=0):(s=s.slice(0,f),n=s.length-1-s.lastIndexOf(r)),o=l,a=0;continue}else if(s.length===2||s.length===1){s="",n=0,o=l,a=0;continue}}e&&(s.length>0?s+=`${r}..`:s="..",n=2)}else s.length>0?s+=r+t.slice(o+1,l):s=t.slice(o+1,l),n=l-o-1;o=l,a=0}else h===46&&a!==-1?++a:a=-1}return s}function _format(t,e){const r=e.dir||e.root,i=e.base||(e.name||"")+(e.ext||"");return r?r===e.root?r+i:r+t+i:i}const WHITESPACE_ENCODINGS={"	":"%09","\n":"%0A","\v":"%0B","\f":"%0C","\r":"%0D"," ":"%20"};function encodeWhitespace(t){return t.replaceAll(/[\s]/g,e=>WHITESPACE_ENCODINGS[e]??e)}const sep="\\",delimiter=";";function resolve(...t){let e="",r="",i=!1;for(let s=t.length-1;s>=-1;s--){let n;const{Deno:o}=globalThis;if(s>=0)n=t[s];else if(e){if(typeof o?.env?.get!="function"||typeof o?.cwd!="function")throw new TypeError("Resolved a relative path without a CWD.");n=o.cwd(),(n===void 0||n.slice(0,3).toLowerCase()!==`${e.toLowerCase()}\\`)&&(n=`${e}\\`)}else{if(typeof o?.cwd!="function")throw new TypeError("Resolved a drive-letter-less path without a CWD.");n=o.cwd()}assertPath(n);const a=n.length;if(a===0)continue;let h=0,l="",c=!1;const f=n.charCodeAt(0);if(a>1)if(isPathSeparator(f))if(c=!0,isPathSeparator(n.charCodeAt(1))){let u=2,A=u;for(;u<a&&!isPathSeparator(n.charCodeAt(u));++u);if(u<a&&u!==A){const _=n.slice(A,u);for(A=u;u<a&&isPathSeparator(n.charCodeAt(u));++u);if(u<a&&u!==A){for(A=u;u<a&&!isPathSeparator(n.charCodeAt(u));++u);u===a?(l=`\\\\${_}\\${n.slice(A)}`,h=u):u!==A&&(l=`\\\\${_}\\${n.slice(A,u)}`,h=u)}}}else h=1;else isWindowsDeviceRoot(f)&&n.charCodeAt(1)===58&&(l=n.slice(0,2),h=2,a>2&&isPathSeparator(n.charCodeAt(2))&&(c=!0,h=3));else isPathSeparator(f)&&(h=1,c=!0);if(!(l.length>0&&e.length>0&&l.toLowerCase()!==e.toLowerCase())&&(e.length===0&&l.length>0&&(e=l),i||(r=`${n.slice(h)}\\${r}`,i=c),i&&e.length>0))break}return r=normalizeString(r,!i,"\\",isPathSeparator),e+(i?"\\":"")+r||"."}function normalize(t){assertPath(t);const e=t.length;if(e===0)return".";let r=0,i,s=!1;const n=t.charCodeAt(0);if(e>1)if(isPathSeparator(n))if(s=!0,isPathSeparator(t.charCodeAt(1))){let a=2,h=a;for(;a<e&&!isPathSeparator(t.charCodeAt(a));++a);if(a<e&&a!==h){const l=t.slice(h,a);for(h=a;a<e&&isPathSeparator(t.charCodeAt(a));++a);if(a<e&&a!==h){for(h=a;a<e&&!isPathSeparator(t.charCodeAt(a));++a);if(a===e)return`\\\\${l}\\${t.slice(h)}\\`;a!==h&&(i=`\\\\${l}\\${t.slice(h,a)}`,r=a)}}}else r=1;else isWindowsDeviceRoot(n)&&t.charCodeAt(1)===58&&(i=t.slice(0,2),r=2,e>2&&isPathSeparator(t.charCodeAt(2))&&(s=!0,r=3));else if(isPathSeparator(n))return"\\";let o;return r<e?o=normalizeString(t.slice(r),!s,"\\",isPathSeparator):o="",o.length===0&&!s&&(o="."),o.length>0&&isPathSeparator(t.charCodeAt(e-1))&&(o+="\\"),i===void 0?s?o.length>0?`\\${o}`:"\\":o.length>0?o:"":s?o.length>0?`${i}\\${o}`:`${i}\\`:o.length>0?i+o:i}function isAbsolute(t){assertPath(t);const e=t.length;if(e===0)return!1;const r=t.charCodeAt(0);return isPathSeparator(r)?!0:!!(isWindowsDeviceRoot(r)&&e>2&&t.charCodeAt(1)===58&&isPathSeparator(t.charCodeAt(2)))}function join(...t){const e=t.length;if(e===0)return".";let r,i=null;for(let o=0;o<e;++o){const a=t[o];assertPath(a),a.length>0&&(r===void 0?r=i=a:r+=`\\${a}`)}if(r===void 0)return".";let s=!0,n=0;if(assert(i!=null),isPathSeparator(i.charCodeAt(0))){++n;const o=i.length;o>1&&isPathSeparator(i.charCodeAt(1))&&(++n,o>2&&(isPathSeparator(i.charCodeAt(2))?++n:s=!1))}if(s){for(;n<r.length&&isPathSeparator(r.charCodeAt(n));++n);n>=2&&(r=`\\${r.slice(n)}`)}return normalize(r)}function relative(t,e){if(assertPath(t),assertPath(e),t===e)return"";const r=resolve(t),i=resolve(e);if(r===i||(t=r.toLowerCase(),e=i.toLowerCase(),t===e))return"";let s=0,n=t.length;for(;s<n&&t.charCodeAt(s)===92;++s);for(;n-1>s&&t.charCodeAt(n-1)===92;--n);const o=n-s;let a=0,h=e.length;for(;a<h&&e.charCodeAt(a)===92;++a);for(;h-1>a&&e.charCodeAt(h-1)===92;--h);const l=h-a,c=o<l?o:l;let f=-1,u=0;for(;u<=c;++u){if(u===c){if(l>c){if(e.charCodeAt(a+u)===92)return i.slice(a+u+1);if(u===2)return i.slice(a+u)}o>c&&(t.charCodeAt(s+u)===92?f=u:u===2&&(f=3));break}const _=t.charCodeAt(s+u),b=e.charCodeAt(a+u);if(_!==b)break;_===92&&(f=u)}if(u!==c&&f===-1)return i;let A="";for(f===-1&&(f=0),u=s+f+1;u<=n;++u)(u===n||t.charCodeAt(u)===92)&&(A.length===0?A+="..":A+="\\..");return A.length>0?A+i.slice(a+f,h):(a+=f,i.charCodeAt(a)===92&&++a,i.slice(a,h))}function toNamespacedPath(t){if(typeof t!="string")return t;if(t.length===0)return"";const e=resolve(t);if(e.length>=3){if(e.charCodeAt(0)===92){if(e.charCodeAt(1)===92){const r=e.charCodeAt(2);if(r!==63&&r!==46)return`\\\\?\\UNC\\${e.slice(2)}`}}else if(isWindowsDeviceRoot(e.charCodeAt(0))&&e.charCodeAt(1)===58&&e.charCodeAt(2)===92)return`\\\\?\\${e}`}return t}function dirname(t){assertPath(t);const e=t.length;if(e===0)return".";let r=-1,i=-1,s=!0,n=0;const o=t.charCodeAt(0);if(e>1)if(isPathSeparator(o)){if(r=n=1,isPathSeparator(t.charCodeAt(1))){let a=2,h=a;for(;a<e&&!isPathSeparator(t.charCodeAt(a));++a);if(a<e&&a!==h){for(h=a;a<e&&isPathSeparator(t.charCodeAt(a));++a);if(a<e&&a!==h){for(h=a;a<e&&!isPathSeparator(t.charCodeAt(a));++a);if(a===e)return t;a!==h&&(r=n=a+1)}}}}else isWindowsDeviceRoot(o)&&t.charCodeAt(1)===58&&(r=n=2,e>2&&isPathSeparator(t.charCodeAt(2))&&(r=n=3));else if(isPathSeparator(o))return t;for(let a=e-1;a>=n;--a)if(isPathSeparator(t.charCodeAt(a))){if(!s){i=a;break}}else s=!1;if(i===-1){if(r===-1)return".";i=r}return t.slice(0,i)}function basename(t,e=""){if(e!==void 0&&typeof e!="string")throw new TypeError('"ext" argument must be a string');assertPath(t);let r=0,i=-1,s=!0,n;if(t.length>=2){const o=t.charCodeAt(0);isWindowsDeviceRoot(o)&&t.charCodeAt(1)===58&&(r=2)}if(e!==void 0&&e.length>0&&e.length<=t.length){if(e.length===t.length&&e===t)return"";let o=e.length-1,a=-1;for(n=t.length-1;n>=r;--n){const h=t.charCodeAt(n);if(isPathSeparator(h)){if(!s){r=n+1;break}}else a===-1&&(s=!1,a=n+1),o>=0&&(h===e.charCodeAt(o)?--o==-1&&(i=n):(o=-1,i=a))}return r===i?i=a:i===-1&&(i=t.length),t.slice(r,i)}else{for(n=t.length-1;n>=r;--n)if(isPathSeparator(t.charCodeAt(n))){if(!s){r=n+1;break}}else i===-1&&(s=!1,i=n+1);return i===-1?"":t.slice(r,i)}}function extname(t){assertPath(t);let e=0,r=-1,i=0,s=-1,n=!0,o=0;t.length>=2&&t.charCodeAt(1)===58&&isWindowsDeviceRoot(t.charCodeAt(0))&&(e=i=2);for(let a=t.length-1;a>=e;--a){const h=t.charCodeAt(a);if(isPathSeparator(h)){if(!n){i=a+1;break}continue}s===-1&&(n=!1,s=a+1),h===46?r===-1?r=a:o!==1&&(o=1):r!==-1&&(o=-1)}return r===-1||s===-1||o===0||o===1&&r===s-1&&r===i+1?"":t.slice(r,s)}function format(t){if(t===null||typeof t!="object")throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof t}`);return _format("\\",t)}function parse1(t){assertPath(t);const e={root:"",dir:"",base:"",ext:"",name:""},r=t.length;if(r===0)return e;let i=0,s=t.charCodeAt(0);if(r>1){if(isPathSeparator(s)){if(i=1,isPathSeparator(t.charCodeAt(1))){let f=2,u=f;for(;f<r&&!isPathSeparator(t.charCodeAt(f));++f);if(f<r&&f!==u){for(u=f;f<r&&isPathSeparator(t.charCodeAt(f));++f);if(f<r&&f!==u){for(u=f;f<r&&!isPathSeparator(t.charCodeAt(f));++f);f===r?i=f:f!==u&&(i=f+1)}}}}else if(isWindowsDeviceRoot(s)&&t.charCodeAt(1)===58)if(i=2,r>2){if(isPathSeparator(t.charCodeAt(2))){if(r===3)return e.root=e.dir=t,e;i=3}}else return e.root=e.dir=t,e}else if(isPathSeparator(s))return e.root=e.dir=t,e;i>0&&(e.root=t.slice(0,i));let n=-1,o=i,a=-1,h=!0,l=t.length-1,c=0;for(;l>=i;--l){if(s=t.charCodeAt(l),isPathSeparator(s)){if(!h){o=l+1;break}continue}a===-1&&(h=!1,a=l+1),s===46?n===-1?n=l:c!==1&&(c=1):n!==-1&&(c=-1)}return n===-1||a===-1||c===0||c===1&&n===a-1&&n===o+1?a!==-1&&(e.base=e.name=t.slice(o,a)):(e.name=t.slice(o,n),e.base=t.slice(o,a),e.ext=t.slice(n,a)),o>0&&o!==i?e.dir=t.slice(0,o-1):e.dir=e.root,e}function fromFileUrl(t){if(t=t instanceof URL?t:new URL(t),t.protocol!="file:")throw new TypeError("Must be a file URL.");let e=decodeURIComponent(t.pathname.replace(/\//g,"\\").replace(/%(?![0-9A-Fa-f]{2})/g,"%25")).replace(/^\\*([A-Za-z]:)(\\|$)/,"$1\\");return t.hostname!=""&&(e=`\\\\${t.hostname}${e}`),e}function toFileUrl(t){if(!isAbsolute(t))throw new TypeError("Must be an absolute path.");const[,e,r]=t.match(/^(?:[/\\]{2}([^/\\]+)(?=[/\\](?:[^/\\]|$)))?(.*)/),i=new URL("file:///");if(i.pathname=encodeWhitespace(r.replace(/%/g,"%25")),e!=null&&e!="localhost"&&(i.hostname=e,!i.hostname))throw new TypeError("Invalid hostname.");return i}const mod1={sep,delimiter,resolve,normalize,isAbsolute,join,relative,toNamespacedPath,dirname,basename,extname,format,parse:parse1,fromFileUrl,toFileUrl},sep1="/",delimiter1=":";function resolve1(...t){let e="",r=!1;for(let i=t.length-1;i>=-1&&!r;i--){let s;if(i>=0)s=t[i];else{const{Deno:n}=globalThis;if(typeof n?.cwd!="function")throw new TypeError("Resolved a relative path without a CWD.");s=n.cwd()}assertPath(s),s.length!==0&&(e=`${s}/${e}`,r=s.charCodeAt(0)===CHAR_FORWARD_SLASH)}return e=normalizeString(e,!r,"/",isPosixPathSeparator),r?e.length>0?`/${e}`:"/":e.length>0?e:"."}function normalize1(t){if(assertPath(t),t.length===0)return".";const e=t.charCodeAt(0)===47,r=t.charCodeAt(t.length-1)===47;return t=normalizeString(t,!e,"/",isPosixPathSeparator),t.length===0&&!e&&(t="."),t.length>0&&r&&(t+="/"),e?`/${t}`:t}function isAbsolute1(t){return assertPath(t),t.length>0&&t.charCodeAt(0)===47}function join1(...t){if(t.length===0)return".";let e;for(let r=0,i=t.length;r<i;++r){const s=t[r];assertPath(s),s.length>0&&(e?e+=`/${s}`:e=s)}return e?normalize1(e):"."}function relative1(t,e){if(assertPath(t),assertPath(e),t===e||(t=resolve1(t),e=resolve1(e),t===e))return"";let r=1;const i=t.length;for(;r<i&&t.charCodeAt(r)===47;++r);const s=i-r;let n=1;const o=e.length;for(;n<o&&e.charCodeAt(n)===47;++n);const a=o-n,h=s<a?s:a;let l=-1,c=0;for(;c<=h;++c){if(c===h){if(a>h){if(e.charCodeAt(n+c)===47)return e.slice(n+c+1);if(c===0)return e.slice(n+c)}else s>h&&(t.charCodeAt(r+c)===47?l=c:c===0&&(l=0));break}const u=t.charCodeAt(r+c),A=e.charCodeAt(n+c);if(u!==A)break;u===47&&(l=c)}let f="";for(c=r+l+1;c<=i;++c)(c===i||t.charCodeAt(c)===47)&&(f.length===0?f+="..":f+="/..");return f.length>0?f+e.slice(n+l):(n+=l,e.charCodeAt(n)===47&&++n,e.slice(n))}function toNamespacedPath1(t){return t}function dirname1(t){if(assertPath(t),t.length===0)return".";const e=t.charCodeAt(0)===47;let r=-1,i=!0;for(let s=t.length-1;s>=1;--s)if(t.charCodeAt(s)===47){if(!i){r=s;break}}else i=!1;return r===-1?e?"/":".":e&&r===1?"//":t.slice(0,r)}function basename1(t,e=""){if(e!==void 0&&typeof e!="string")throw new TypeError('"ext" argument must be a string');assertPath(t);let r=0,i=-1,s=!0,n;if(e!==void 0&&e.length>0&&e.length<=t.length){if(e.length===t.length&&e===t)return"";let o=e.length-1,a=-1;for(n=t.length-1;n>=0;--n){const h=t.charCodeAt(n);if(h===47){if(!s){r=n+1;break}}else a===-1&&(s=!1,a=n+1),o>=0&&(h===e.charCodeAt(o)?--o==-1&&(i=n):(o=-1,i=a))}return r===i?i=a:i===-1&&(i=t.length),t.slice(r,i)}else{for(n=t.length-1;n>=0;--n)if(t.charCodeAt(n)===47){if(!s){r=n+1;break}}else i===-1&&(s=!1,i=n+1);return i===-1?"":t.slice(r,i)}}function extname1(t){assertPath(t);let e=-1,r=0,i=-1,s=!0,n=0;for(let o=t.length-1;o>=0;--o){const a=t.charCodeAt(o);if(a===47){if(!s){r=o+1;break}continue}i===-1&&(s=!1,i=o+1),a===46?e===-1?e=o:n!==1&&(n=1):e!==-1&&(n=-1)}return e===-1||i===-1||n===0||n===1&&e===i-1&&e===r+1?"":t.slice(e,i)}function format1(t){if(t===null||typeof t!="object")throw new TypeError(`The "pathObject" argument must be of type Object. Received type ${typeof t}`);return _format("/",t)}function parse2(t){assertPath(t);const e={root:"",dir:"",base:"",ext:"",name:""};if(t.length===0)return e;const r=t.charCodeAt(0)===47;let i;r?(e.root="/",i=1):i=0;let s=-1,n=0,o=-1,a=!0,h=t.length-1,l=0;for(;h>=i;--h){const c=t.charCodeAt(h);if(c===47){if(!a){n=h+1;break}continue}o===-1&&(a=!1,o=h+1),c===46?s===-1?s=h:l!==1&&(l=1):s!==-1&&(l=-1)}return s===-1||o===-1||l===0||l===1&&s===o-1&&s===n+1?o!==-1&&(n===0&&r?e.base=e.name=t.slice(1,o):e.base=e.name=t.slice(n,o)):(n===0&&r?(e.name=t.slice(1,s),e.base=t.slice(1,o)):(e.name=t.slice(n,s),e.base=t.slice(n,o)),e.ext=t.slice(s,o)),n>0?e.dir=t.slice(0,n-1):r&&(e.dir="/"),e}function fromFileUrl1(t){if(t=t instanceof URL?t:new URL(t),t.protocol!="file:")throw new TypeError("Must be a file URL.");return decodeURIComponent(t.pathname.replace(/%(?![0-9A-Fa-f]{2})/g,"%25"))}function toFileUrl1(t){if(!isAbsolute1(t))throw new TypeError("Must be an absolute path.");const e=new URL("file:///");return e.pathname=encodeWhitespace(t.replace(/%/g,"%25").replace(/\\/g,"%5C")),e}const mod2={sep:sep1,delimiter:delimiter1,resolve:resolve1,normalize:normalize1,isAbsolute:isAbsolute1,join:join1,relative:relative1,toNamespacedPath:toNamespacedPath1,dirname:dirname1,basename:basename1,extname:extname1,format:format1,parse:parse2,fromFileUrl:fromFileUrl1,toFileUrl:toFileUrl1},path=isWindows?mod1:mod2,{join:join2,normalize:normalize2}=path,path1=isWindows?mod1:mod2,{basename:basename2,delimiter:delimiter2,dirname:dirname2,extname:extname2,format:format2,fromFileUrl:fromFileUrl2,isAbsolute:isAbsolute2,join:join3,normalize:normalize3,parse:parse3,relative:relative2,resolve:resolve2,sep:sep2,toFileUrl:toFileUrl2,toNamespacedPath:toNamespacedPath2}=path1;function isString(t){return typeof t=="string"}function isArray(t,e){return Array.isArray(t)&&(!e||t.every(e))}class EnsureError extends Error{constructor(e){super(e);Error.captureStackTrace&&Error.captureStackTrace(this,EnsureError),this.name="EnsureError"}}function ensure(t,e,r="The value is not expected type"){if(!e(t))throw new EnsureError(r)}function ensureString(t){return ensure(t,isString,"The value must be string")}function ensureArray(t,e){return ensure(t,i=>isArray(i,e),"The value must be array")}function deferred(){let t;const e=new Promise((r,i)=>{t={resolve:r,reject:i}});return Object.assign(e,t)}class Lock{#e;constructor(){this.#e=[]}async with(e){await this.acquire();try{await(e()??Promise.resolve())}finally{this.release()}}async acquire(){const e=[...this.#e];return this.#e.push(deferred()),e.length&&await Promise.all(e),!0}release(){const e=this.#e.shift();if(e)e.resolve();else throw new Error("The lock is not locked")}locked(){return!!this.#e.length}}class Event{#e;constructor(){this.#e=deferred()}async wait(){return this.#e&&await this.#e,!0}set(){this.#e&&(this.#e.resolve(),this.#e=null)}clear(){this.#e||(this.#e=deferred())}is_set(){return!this.#e}}class Condition{#e;#t;constructor(e){this.#e=e??new Lock,this.#t=[]}async with(e){await this.acquire();try{await(e()??Promise.resolve())}finally{this.release()}}async acquire(){return await this.#e.acquire(),!0}release(){this.#e.release()}locked(){return this.#e.locked()}notify(e=1){if(!this.locked())throw new Error("The lock is not acquired");for(const r of Array(e)){const i=this.#t.shift();if(!i)break;i.set()}}notify_all(){this.notify(this.#t.length)}async wait(){if(!this.locked())throw new Error("The lock is not acquired");const e=new Event;return this.#t.push(e),this.release(),await e.wait(),await this.acquire(),!0}async wait_for(e){for(;!e();)await this.wait()}}class QueueEmpty extends Error{}class QueueFull extends Error{}class Queue{#e;#t;#i;#r;constructor(e=0){this.#e=[],this.#t=e<=0?0:e,this.#i=new Condition,this.#r=new Condition}empty(){return!this.#e.length}full(){return!!this.#t&&this.#e.length===this.#t}async get(){const e=this.#e.shift();return e?(await this.#i.with(()=>{this.#i.notify()}),e):new Promise(r=>{this.#r.with(async()=>{await this.#r.wait_for(()=>!!this.#e.length),r(await this.get())})})}get_nowait(){const e=this.#e.shift();if(!e)throw new QueueEmpty("Queue empty");return this.#i.with(()=>{this.#i.notify()}),e}async put(e){if(this.#t&&this.#e.length>=this.#t){await this.#i.with(async()=>{await this.#i.wait_for(()=>this.#e.length<this.#t),await this.put(e)});return}await this.#r.with(()=>{this.#r.notify()}),this.#e.push(e)}put_nowait(e){if(this.#t&&this.#e.length>=this.#t)throw new QueueFull("Queue full");this.#r.with(()=>{this.#r.notify()}),this.#e.push(e)}qsize(){return this.#e.length}}function deferred1(){let t,e="pending";const r=new Promise((i,s)=>{t={async resolve(n){await n,e="fulfilled",i(n)},reject(n){e="rejected",s(n)}}});return Object.defineProperty(r,"state",{get:()=>e}),Object.assign(r,t)}const semver=/^v?(?:\d+)(\.(?:[x*]|\d+)(\.(?:[x*]|\d+)(\.(?:[x*]|\d+))?(?:-[\da-z\-]+(?:\.[\da-z\-]+)*)?(?:\+[\da-z\-]+(?:\.[\da-z\-]+)*)?)?)?$/i,indexOrEnd=(t,e)=>t.indexOf(e)===-1?t.length:t.indexOf(e),split=t=>{const e=t.replace(/^v/,"").replace(/\+.*$/,""),r=indexOrEnd(e,"-"),i=e.substring(0,r).split(".");return i.push(e.substring(r+1)),i},tryParse=t=>isNaN(Number(t))?t:Number(t),validate=t=>{if(typeof t!="string")throw new TypeError("Invalid argument expected string");if(!semver.test(t))throw new Error("Invalid argument not valid semver ('"+t+"' received)")},compareVersions=(t,e)=>{[t,e].forEach(validate);const r=split(t),i=split(e);for(let o=0;o<Math.max(r.length-1,i.length-1);o++){const a=parseInt(r[o]||"0",10),h=parseInt(i[o]||"0",10);if(a>h)return 1;if(h>a)return-1}const s=r[r.length-1],n=i[i.length-1];if(s&&n){const o=s.split(".").map(tryParse),a=n.split(".").map(tryParse);for(let h=0;h<Math.max(o.length,a.length);h++){if(o[h]===void 0||typeof a[h]=="string"&&typeof o[h]=="number")return-1;if(a[h]===void 0||typeof o[h]=="string"&&typeof a[h]=="number"||o[h]>a[h])return 1;if(a[h]>o[h])return-1}}else if(s||n)return s?-1:1;return 0},allowedOperators=[">",">=","=","<","<="],operatorResMap={">":[1],">=":[0,1],"=":[0],"<=":[-1,0],"<":[-1]},validateOperator=t=>{if(typeof t!="string")throw new TypeError("Invalid operator type, expected string but got "+typeof t);if(allowedOperators.indexOf(t)===-1)throw new TypeError("Invalid operator, expected one of "+allowedOperators.join("|"))};compareVersions.validate=t=>typeof t=="string"&&semver.test(t),compareVersions.compare=(t,e,r)=>{validateOperator(r);const i=compareVersions(t,e);return operatorResMap[r].indexOf(i)>-1};class WorkerReader{#e;#t;#i;#r;#n;constructor(e){this.#e=new Queue,this.#t=new Uint8Array,this.#i=!1,this.#r=deferred1(),this.#n=e,this.#n.onmessage=r=>{this.#e&&!this.#i&&this.#e.put_nowait(r.data)}}async read(e){if(this.#t.length)return this.readFromRemain(e);if(!this.#e||this.#i&&this.#e.empty())return this.#e=void 0,null;if(!this.#e?.empty())return this.#t=this.#e.get_nowait(),this.readFromRemain(e);const r=await Promise.race([this.#e.get(),this.#r]);return r==null?await this.read(e):(this.#t=r,this.readFromRemain(e))}readFromRemain(e){const r=e.byteLength,i=this.#t.subarray(0,r);return this.#t=this.#t.subarray(r),e.set(i),i.byteLength}close(){this.#i=!0,this.#r.resolve()}}const supportTransfer=compareVersions(Deno.version.deno,"1.14.0")>=0;class WorkerWriter{#e;constructor(e){this.#e=e}write(e){if(supportTransfer){const r=new Uint8Array(e);this.#e.postMessage(r,[r.buffer])}else this.#e.postMessage(e);return Promise.resolve(e.length)}}function utf8Count(t){const e=t.length;let r=0,i=0;for(;i<e;){let s=t.charCodeAt(i++);if((s&4294967168)==0){r++;continue}else if((s&4294965248)==0)r+=2;else{if(s>=55296&&s<=56319&&i<e){const n=t.charCodeAt(i);(n&64512)==56320&&(++i,s=((s&1023)<<10)+(n&1023)+65536)}(s&4294901760)==0?r+=3:r+=4}}return r}function utf8EncodeJs(t,e,r){const i=t.length;let s=r,n=0;for(;n<i;){let o=t.charCodeAt(n++);if((o&4294967168)==0){e[s++]=o;continue}else if((o&4294965248)==0)e[s++]=o>>6&31|192;else{if(o>=55296&&o<=56319&&n<i){const a=t.charCodeAt(n);(a&64512)==56320&&(++n,o=((o&1023)<<10)+(a&1023)+65536)}(o&4294901760)==0?(e[s++]=o>>12&15|224,e[s++]=o>>6&63|128):(e[s++]=o>>18&7|240,e[s++]=o>>12&63|128,e[s++]=o>>6&63|128)}e[s++]=o&63|128}}const sharedTextEncoder=new TextEncoder;function utf8EncodeTEencodeInto(t,e,r){sharedTextEncoder.encodeInto(t,e.subarray(r))}const utf8EncodeTE=utf8EncodeTEencodeInto;function utf8DecodeJs(t,e,r){let i=e;const s=i+r,n=[];let o="";for(;i<s;){const a=t[i++];if((a&128)==0)n.push(a);else if((a&224)==192){const h=t[i++]&63;n.push((a&31)<<6|h)}else if((a&240)==224){const h=t[i++]&63,l=t[i++]&63;n.push((a&31)<<12|h<<6|l)}else if((a&248)==240){const h=t[i++]&63,l=t[i++]&63,c=t[i++]&63;let f=(a&7)<<18|h<<12|l<<6|c;f>65535&&(f-=65536,n.push(f>>>10&1023|55296),f=56320|f&1023),n.push(f)}else n.push(a);n.length>=4096&&(o+=String.fromCharCode(...n),n.length=0)}return n.length>0&&(o+=String.fromCharCode(...n)),o}const sharedTextDecoder=new TextDecoder;function utf8DecodeTD(t,e,r){const i=t.subarray(e,e+r);return sharedTextDecoder.decode(i)}class ExtData{type;data;constructor(e,r){this.type=e,this.data=r}}function setUint64(t,e,r){const i=r/4294967296,s=r;t.setUint32(e,i),t.setUint32(e+4,s)}function setInt64(t,e,r){const i=Math.floor(r/4294967296),s=r;t.setUint32(e,i),t.setUint32(e+4,s)}function getInt64(t,e){const r=t.getInt32(e),i=t.getUint32(e+4);return r*4294967296+i}function getUint64(t,e){const r=t.getUint32(e),i=t.getUint32(e+4);return r*4294967296+i}const EXT_TIMESTAMP=-1,TIMESTAMP32_MAX_SEC=4294967296-1,TIMESTAMP64_MAX_SEC=17179869184-1;function encodeTimeSpecToTimestamp({sec:t,nsec:e}){if(t>=0&&e>=0&&t<=TIMESTAMP64_MAX_SEC)if(e===0&&t<=TIMESTAMP32_MAX_SEC){const r=new Uint8Array(4);return new DataView(r.buffer).setUint32(0,t),r}else{const r=t/4294967296,i=t&4294967295,s=new Uint8Array(8),n=new DataView(s.buffer);return n.setUint32(0,e<<2|r&3),n.setUint32(4,i),s}else{const r=new Uint8Array(12),i=new DataView(r.buffer);return i.setUint32(0,e),setInt64(i,4,t),r}}function encodeDateToTimeSpec(t){const e=t.getTime(),r=Math.floor(e/1e3),i=(e-r*1e3)*1e6,s=Math.floor(i/1e9);return{sec:r+s,nsec:i-s*1e9}}function encodeTimestampExtension(t){if(t instanceof Date){const e=encodeDateToTimeSpec(t);return encodeTimeSpecToTimestamp(e)}else return null}function decodeTimestampToTimeSpec(t){const e=new DataView(t.buffer,t.byteOffset,t.byteLength);switch(t.byteLength){case 4:return{sec:e.getUint32(0),nsec:0};case 8:{const r=e.getUint32(0),i=e.getUint32(4),s=(r&3)*4294967296+i,n=r>>>2;return{sec:s,nsec:n}}case 12:{const r=getInt64(e,4),i=e.getUint32(0);return{sec:r,nsec:i}}default:throw new Error(`Unrecognized data size for timestamp: ${t.length}`)}}function decodeTimestampExtension(t){const e=decodeTimestampToTimeSpec(t);return new Date(e.sec*1e3+e.nsec/1e6)}const timestampExtension={type:EXT_TIMESTAMP,encode:encodeTimestampExtension,decode:decodeTimestampExtension};class ExtensionCodec{static defaultCodec=new ExtensionCodec;__brand;builtInEncoders=[];builtInDecoders=[];encoders=[];decoders=[];constructor(){this.register(timestampExtension)}register({type:e,encode:r,decode:i}){if(e>=0)this.encoders[e]=r,this.decoders[e]=i;else{const s=1+e;this.builtInEncoders[s]=r,this.builtInDecoders[s]=i}}tryToEncode(e,r){for(let i=0;i<this.builtInEncoders.length;i++){const s=this.builtInEncoders[i];if(s!=null){const n=s(e,r);if(n!=null){const o=-1-i;return new ExtData(o,n)}}}for(let i=0;i<this.encoders.length;i++){const s=this.encoders[i];if(s!=null){const n=s(e,r);if(n!=null){const o=i;return new ExtData(o,n)}}}return e instanceof ExtData?e:null}decode(e,r,i){const s=r<0?this.builtInDecoders[-1-r]:this.decoders[r];return s?s(e,r,i):new ExtData(r,e)}}function ensureUint8Array(t){return t instanceof Uint8Array?t:ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):t instanceof ArrayBuffer?new Uint8Array(t):Uint8Array.from(t)}function createDataView(t){if(t instanceof ArrayBuffer)return new DataView(t);const e=ensureUint8Array(t);return new DataView(e.buffer,e.byteOffset,e.byteLength)}class Encoder{extensionCodec;context;maxDepth;initialBufferSize;sortKeys;forceFloat32;ignoreUndefined;pos=0;view;bytes;constructor(e=ExtensionCodec.defaultCodec,r=void 0,i=100,s=2048,n=!1,o=!1,a=!1){this.extensionCodec=e,this.context=r,this.maxDepth=i,this.initialBufferSize=s,this.sortKeys=n,this.forceFloat32=o,this.ignoreUndefined=a,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}getUint8Array(){return this.bytes.subarray(0,this.pos)}reinitializeState(){this.pos=0}encode(e){return this.reinitializeState(),this.doEncode(e,1),this.getUint8Array()}doEncode(e,r){if(r>this.maxDepth)throw new Error(`Too deep objects in depth ${r}`);e==null?this.encodeNil():typeof e=="boolean"?this.encodeBoolean(e):typeof e=="number"?this.encodeNumber(e):typeof e=="string"?this.encodeString(e):this.encodeObject(e,r)}ensureBufferSizeToWrite(e){const r=this.pos+e;this.view.byteLength<r&&this.resizeBuffer(r*2)}resizeBuffer(e){const r=new ArrayBuffer(e),i=new Uint8Array(r),s=new DataView(r);i.set(this.bytes),this.view=s,this.bytes=i}encodeNil(){this.writeU8(192)}encodeBoolean(e){e===!1?this.writeU8(194):this.writeU8(195)}encodeNumber(e){Number.isSafeInteger(e)?e>=0?e<128?this.writeU8(e):e<256?(this.writeU8(204),this.writeU8(e)):e<65536?(this.writeU8(205),this.writeU16(e)):e<4294967296?(this.writeU8(206),this.writeU32(e)):(this.writeU8(207),this.writeU64(e)):e>=-32?this.writeU8(224|e+32):e>=-128?(this.writeU8(208),this.writeI8(e)):e>=-32768?(this.writeU8(209),this.writeI16(e)):e>=-2147483648?(this.writeU8(210),this.writeI32(e)):(this.writeU8(211),this.writeI64(e)):this.forceFloat32?(this.writeU8(202),this.writeF32(e)):(this.writeU8(203),this.writeF64(e))}writeStringHeader(e){if(e<32)this.writeU8(160+e);else if(e<256)this.writeU8(217),this.writeU8(e);else if(e<65536)this.writeU8(218),this.writeU16(e);else if(e<4294967296)this.writeU8(219),this.writeU32(e);else throw new Error(`Too long string: ${e} bytes in UTF-8`)}encodeString(e){const r=1+4;if(e.length>200){const s=utf8Count(e);this.ensureBufferSizeToWrite(r+s),this.writeStringHeader(s),utf8EncodeTE(e,this.bytes,this.pos),this.pos+=s}else{const s=utf8Count(e);this.ensureBufferSizeToWrite(r+s),this.writeStringHeader(s),utf8EncodeJs(e,this.bytes,this.pos),this.pos+=s}}encodeObject(e,r){const i=this.extensionCodec.tryToEncode(e,this.context);if(i!=null)this.encodeExtension(i);else if(Array.isArray(e))this.encodeArray(e,r);else if(ArrayBuffer.isView(e))this.encodeBinary(e);else if(typeof e=="object")this.encodeMap(e,r);else throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(e)}`)}encodeBinary(e){const r=e.byteLength;if(r<256)this.writeU8(196),this.writeU8(r);else if(r<65536)this.writeU8(197),this.writeU16(r);else if(r<4294967296)this.writeU8(198),this.writeU32(r);else throw new Error(`Too large binary: ${r}`);const i=ensureUint8Array(e);this.writeU8a(i)}encodeArray(e,r){const i=e.length;if(i<16)this.writeU8(144+i);else if(i<65536)this.writeU8(220),this.writeU16(i);else if(i<4294967296)this.writeU8(221),this.writeU32(i);else throw new Error(`Too large array: ${i}`);for(const s of e)this.doEncode(s,r+1)}countWithoutUndefined(e,r){let i=0;for(const s of r)e[s]!==void 0&&i++;return i}encodeMap(e,r){const i=Object.keys(e);this.sortKeys&&i.sort();const s=this.ignoreUndefined?this.countWithoutUndefined(e,i):i.length;if(s<16)this.writeU8(128+s);else if(s<65536)this.writeU8(222),this.writeU16(s);else if(s<4294967296)this.writeU8(223),this.writeU32(s);else throw new Error(`Too large map object: ${s}`);for(const n of i){const o=e[n];this.ignoreUndefined&&o===void 0||(this.encodeString(n),this.doEncode(o,r+1))}}encodeExtension(e){const r=e.data.length;if(r===1)this.writeU8(212);else if(r===2)this.writeU8(213);else if(r===4)this.writeU8(214);else if(r===8)this.writeU8(215);else if(r===16)this.writeU8(216);else if(r<256)this.writeU8(199),this.writeU8(r);else if(r<65536)this.writeU8(200),this.writeU16(r);else if(r<4294967296)this.writeU8(201),this.writeU32(r);else throw new Error(`Too large extension object: ${r}`);this.writeI8(e.type),this.writeU8a(e.data)}writeU8(e){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,e),this.pos++}writeU8a(e){const r=e.length;this.ensureBufferSizeToWrite(r),this.bytes.set(e,this.pos),this.pos+=r}writeI8(e){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,e),this.pos++}writeU16(e){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,e),this.pos+=2}writeI16(e){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,e),this.pos+=2}writeU32(e){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,e),this.pos+=4}writeI32(e){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,e),this.pos+=4}writeF32(e){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,e),this.pos+=4}writeF64(e){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,e),this.pos+=8}writeU64(e){this.ensureBufferSizeToWrite(8),setUint64(this.view,this.pos,e),this.pos+=8}writeI64(e){this.ensureBufferSizeToWrite(8),setInt64(this.view,this.pos,e),this.pos+=8}}const defaultEncodeOptions={};function encode1(t,e=defaultEncodeOptions){return new Encoder(e.extensionCodec,e.context,e.maxDepth,e.initialBufferSize,e.sortKeys,e.forceFloat32,e.ignoreUndefined).encode(t)}function prettyByte(t){return`${t<0?"-":""}0x${Math.abs(t).toString(16).padStart(2,"0")}`}class CachedKeyDecoder{maxKeyLength;maxLengthPerKey;hit=0;miss=0;caches;constructor(e=16,r=16){this.maxKeyLength=e,this.maxLengthPerKey=r,this.caches=[];for(let i=0;i<this.maxKeyLength;i++)this.caches.push([])}canBeCached(e){return e>0&&e<=this.maxKeyLength}get(e,r,i){const s=this.caches[i-1],n=s.length;e:for(let o=0;o<n;o++){const a=s[o],h=a.bytes;for(let l=0;l<i;l++)if(h[l]!==e[r+l])continue e;return a.value}return null}store(e,r){const i=this.caches[e.length-1],s={bytes:e,value:r};i.length>=this.maxLengthPerKey?i[Math.random()*i.length|0]=s:i.push(s)}decode(e,r,i){const s=this.get(e,r,i);if(s!=null)return this.hit++,s;this.miss++;const n=utf8DecodeJs(e,r,i),o=Uint8Array.prototype.slice.call(e,r,r+i);return this.store(o,n),n}}var State;(function(t){t[t.ARRAY=0]="ARRAY",t[t.MAP_KEY=1]="MAP_KEY",t[t.MAP_VALUE=2]="MAP_VALUE"})(State||(State={}));const isValidMapKeyType=t=>{const e=typeof t;return e==="string"||e==="number"},HEAD_BYTE_REQUIRED=-1,EMPTY_VIEW=new DataView(new ArrayBuffer(0)),EMPTY_BYTES=new Uint8Array(EMPTY_VIEW.buffer),DataViewIndexOutOfBoundsError=(()=>{try{EMPTY_VIEW.getInt8(0)}catch(t){return t.constructor}throw new Error("never reached")})(),MORE_DATA=new DataViewIndexOutOfBoundsError("Insufficient data"),sharedCachedKeyDecoder=new CachedKeyDecoder;class Decoder{extensionCodec;context;maxStrLength;maxBinLength;maxArrayLength;maxMapLength;maxExtLength;keyDecoder;totalPos=0;pos=0;view=EMPTY_VIEW;bytes=EMPTY_BYTES;headByte=HEAD_BYTE_REQUIRED;stack=[];constructor(e=ExtensionCodec.defaultCodec,r=void 0,i=4294967295,s=4294967295,n=4294967295,o=4294967295,a=4294967295,h=sharedCachedKeyDecoder){this.extensionCodec=e,this.context=r,this.maxStrLength=i,this.maxBinLength=s,this.maxArrayLength=n,this.maxMapLength=o,this.maxExtLength=a,this.keyDecoder=h}reinitializeState(){this.totalPos=0,this.headByte=HEAD_BYTE_REQUIRED}setBuffer(e){this.bytes=ensureUint8Array(e),this.view=createDataView(this.bytes),this.pos=0}appendBuffer(e){if(e=ensureUint8Array(e).slice(),this.headByte===HEAD_BYTE_REQUIRED&&!this.hasRemaining())this.setBuffer(e);else{const r=this.bytes.subarray(this.pos),i=ensureUint8Array(e),s=new Uint8Array(r.length+i.length);s.set(r),s.set(i,r.length),this.setBuffer(s)}}hasRemaining(e=1){return this.view.byteLength-this.pos>=e}createNoExtraBytesError(e){const{view:r,pos:i}=this;return new RangeError(`Extra ${r.byteLength-i} of ${r.byteLength} byte(s) found at buffer[${e}]`)}decode(e){return this.reinitializeState(),this.setBuffer(e),this.doDecodeSingleSync()}doDecodeSingleSync(){const e=this.doDecodeSync();if(this.hasRemaining())throw this.createNoExtraBytesError(this.pos);return e}async decodeAsync(e){let r=!1,i;for await(const a of e){if(r)throw this.createNoExtraBytesError(this.totalPos);this.appendBuffer(a);try{i=this.doDecodeSync(),r=!0}catch(h){if(!(h instanceof DataViewIndexOutOfBoundsError))throw h}this.totalPos+=this.pos}if(r){if(this.hasRemaining())throw this.createNoExtraBytesError(this.totalPos);return i}const{headByte:s,pos:n,totalPos:o}=this;throw new RangeError(`Insufficient data in parcing ${prettyByte(s)} at ${o} (${n} in the current buffer)`)}decodeArrayStream(e){return this.decodeMultiAsync(e,!0)}decodeStream(e){return this.decodeMultiAsync(e,!1)}async*decodeMultiAsync(e,r){let i=r,s=-1;for await(const n of e){if(r&&s===0)throw this.createNoExtraBytesError(this.totalPos);this.appendBuffer(n),i&&(s=this.readArraySize(),i=!1,this.complete());try{for(;yield this.doDecodeSync(),--s!=0;);}catch(o){if(!(o instanceof DataViewIndexOutOfBoundsError))throw o}this.totalPos+=this.pos}}doDecodeSync(){e:for(;;){const e=this.readHeadByte();let r;if(e>=224)r=e-256;else if(e<192)if(e<128)r=e;else if(e<144){const s=e-128;if(s!==0){this.pushMapState(s),this.complete();continue e}else r={}}else if(e<160){const s=e-144;if(s!==0){this.pushArrayState(s),this.complete();continue e}else r=[]}else{const s=e-160;r=this.decodeUtf8String(s,0)}else if(e===192)r=null;else if(e===194)r=!1;else if(e===195)r=!0;else if(e===202)r=this.readF32();else if(e===203)r=this.readF64();else if(e===204)r=this.readU8();else if(e===205)r=this.readU16();else if(e===206)r=this.readU32();else if(e===207)r=this.readU64();else if(e===208)r=this.readI8();else if(e===209)r=this.readI16();else if(e===210)r=this.readI32();else if(e===211)r=this.readI64();else if(e===217){const s=this.lookU8();r=this.decodeUtf8String(s,1)}else if(e===218){const s=this.lookU16();r=this.decodeUtf8String(s,2)}else if(e===219){const s=this.lookU32();r=this.decodeUtf8String(s,4)}else if(e===220){const s=this.readU16();if(s!==0){this.pushArrayState(s),this.complete();continue e}else r=[]}else if(e===221){const s=this.readU32();if(s!==0){this.pushArrayState(s),this.complete();continue e}else r=[]}else if(e===222){const s=this.readU16();if(s!==0){this.pushMapState(s),this.complete();continue e}else r={}}else if(e===223){const s=this.readU32();if(s!==0){this.pushMapState(s),this.complete();continue e}else r={}}else if(e===196){const s=this.lookU8();r=this.decodeBinary(s,1)}else if(e===197){const s=this.lookU16();r=this.decodeBinary(s,2)}else if(e===198){const s=this.lookU32();r=this.decodeBinary(s,4)}else if(e===212)r=this.decodeExtension(1,0);else if(e===213)r=this.decodeExtension(2,0);else if(e===214)r=this.decodeExtension(4,0);else if(e===215)r=this.decodeExtension(8,0);else if(e===216)r=this.decodeExtension(16,0);else if(e===199){const s=this.lookU8();r=this.decodeExtension(s,1)}else if(e===200){const s=this.lookU16();r=this.decodeExtension(s,2)}else if(e===201){const s=this.lookU32();r=this.decodeExtension(s,4)}else throw new Error(`Unrecognized type byte: ${prettyByte(e)}`);this.complete();const i=this.stack;for(;i.length>0;){const s=i[i.length-1];if(s.type===State.ARRAY)if(s.array[s.position]=r,s.position++,s.position===s.size)i.pop(),r=s.array;else continue e;else if(s.type===State.MAP_KEY){if(!isValidMapKeyType(r))throw new Error("The type of key must be string or number but "+typeof r);s.key=r,s.type=State.MAP_VALUE;continue e}else if(s.map[s.key]=r,s.readCount++,s.readCount===s.size)i.pop(),r=s.map;else{s.key=null,s.type=State.MAP_KEY;continue e}}return r}}readHeadByte(){return this.headByte===HEAD_BYTE_REQUIRED&&(this.headByte=this.readU8()),this.headByte}complete(){this.headByte=HEAD_BYTE_REQUIRED}readArraySize(){const e=this.readHeadByte();switch(e){case 220:return this.readU16();case 221:return this.readU32();default:{if(e<160)return e-144;throw new Error(`Unrecognized array type byte: ${prettyByte(e)}`)}}}pushMapState(e){if(e>this.maxMapLength)throw new Error(`Max length exceeded: map length (${e}) > maxMapLengthLength (${this.maxMapLength})`);this.stack.push({type:State.MAP_KEY,size:e,key:null,readCount:0,map:{}})}pushArrayState(e){if(e>this.maxArrayLength)throw new Error(`Max length exceeded: array length (${e}) > maxArrayLength (${this.maxArrayLength})`);this.stack.push({type:State.ARRAY,size:e,array:new Array(e),position:0})}decodeUtf8String(e,r){if(e>this.maxStrLength)throw new Error(`Max length exceeded: UTF-8 byte length (${e}) > maxStrLength (${this.maxStrLength})`);if(this.bytes.byteLength<this.pos+r+e)throw MORE_DATA;const i=this.pos+r;let s;return this.stateIsMapKey()&&this.keyDecoder?.canBeCached(e)?s=this.keyDecoder.decode(this.bytes,i,e):e>200?s=utf8DecodeTD(this.bytes,i,e):s=utf8DecodeJs(this.bytes,i,e),this.pos+=r+e,s}stateIsMapKey(){return this.stack.length>0?this.stack[this.stack.length-1].type===State.MAP_KEY:!1}decodeBinary(e,r){if(e>this.maxBinLength)throw new Error(`Max length exceeded: bin length (${e}) > maxBinLength (${this.maxBinLength})`);if(!this.hasRemaining(e+r))throw MORE_DATA;const i=this.pos+r,s=this.bytes.subarray(i,i+e);return this.pos+=r+e,s}decodeExtension(e,r){if(e>this.maxExtLength)throw new Error(`Max length exceeded: ext length (${e}) > maxExtLength (${this.maxExtLength})`);const i=this.view.getInt8(this.pos+r),s=this.decodeBinary(e,r+1);return this.extensionCodec.decode(s,i,this.context)}lookU8(){return this.view.getUint8(this.pos)}lookU16(){return this.view.getUint16(this.pos)}lookU32(){return this.view.getUint32(this.pos)}readU8(){const e=this.view.getUint8(this.pos);return this.pos++,e}readI8(){const e=this.view.getInt8(this.pos);return this.pos++,e}readU16(){const e=this.view.getUint16(this.pos);return this.pos+=2,e}readI16(){const e=this.view.getInt16(this.pos);return this.pos+=2,e}readU32(){const e=this.view.getUint32(this.pos);return this.pos+=4,e}readI32(){const e=this.view.getInt32(this.pos);return this.pos+=4,e}readU64(){const e=getUint64(this.view,this.pos);return this.pos+=8,e}readI64(){const e=getInt64(this.view,this.pos);return this.pos+=8,e}readF32(){const e=this.view.getFloat32(this.pos);return this.pos+=4,e}readF64(){const e=this.view.getFloat64(this.pos);return this.pos+=8,e}}const defaultDecodeOptions={};function isAsyncIterable(t){return t[Symbol.asyncIterator]!=null}function assertNonNull(t){if(t==null)throw new Error("Assertion Failure: value must not be null nor undefined")}async function*asyncIterableFromStream(t){const e=t.getReader();try{for(;;){const{done:r,value:i}=await e.read();if(r)return;assertNonNull(i),yield i}}finally{e.releaseLock()}}function ensureAsyncIterabe(t){return isAsyncIterable(t)?t:asyncIterableFromStream(t)}function decodeStream(t,e=defaultDecodeOptions){const r=ensureAsyncIterabe(t);return new Decoder(e.extensionCodec,e.context,e.maxStrLength,e.maxBinLength,e.maxArrayLength,e.maxMapLength,e.maxExtLength).decodeStream(r)}function deferred2(){let t,e="pending";const r=new Promise((i,s)=>{t={async resolve(n){await n,e="fulfilled",i(n)},reject(n){e="rejected",s(n)}}});return Object.defineProperty(r,"state",{get:()=>e}),Object.assign(r,t)}class DenoStdInternalError1 extends Error{constructor(e){super(e);this.name="DenoStdInternalError"}}function assert1(t,e=""){if(!t)throw new DenoStdInternalError1(e)}function concat(...t){let e=0;for(const s of t)e+=s.length;const r=new Uint8Array(e);let i=0;for(const s of t)r.set(s,i),i+=s.length;return r}function copy(t,e,r=0){r=Math.max(0,Math.min(r,e.byteLength));const i=e.byteLength-r;return t.byteLength>i&&(t=t.subarray(0,i)),e.set(t,r),t.byteLength}const MIN_READ=32*1024,MAX_SIZE=2**32-2;class Buffer{#e;#t=0;constructor(e){this.#e=e===void 0?new Uint8Array(0):new Uint8Array(e)}bytes(e={copy:!0}){return e.copy===!1?this.#e.subarray(this.#t):this.#e.slice(this.#t)}empty(){return this.#e.byteLength<=this.#t}get length(){return this.#e.byteLength-this.#t}get capacity(){return this.#e.buffer.byteLength}truncate(e){if(e===0){this.reset();return}if(e<0||e>this.length)throw Error("bytes.Buffer: truncation out of range");this.#r(this.#t+e)}reset(){this.#r(0),this.#t=0}#i(e){const r=this.#e.byteLength;return e<=this.capacity-r?(this.#r(r+e),r):-1}#r(e){assert1(e<=this.#e.buffer.byteLength),this.#e=new Uint8Array(this.#e.buffer,0,e)}readSync(e){if(this.empty())return this.reset(),e.byteLength===0?0:null;const r=copy(this.#e.subarray(this.#t),e);return this.#t+=r,r}read(e){const r=this.readSync(e);return Promise.resolve(r)}writeSync(e){const r=this.#n(e.byteLength);return copy(e,this.#e,r)}write(e){const r=this.writeSync(e);return Promise.resolve(r)}#n(e){const r=this.length;r===0&&this.#t!==0&&this.reset();const i=this.#i(e);if(i>=0)return i;const s=this.capacity;if(e<=Math.floor(s/2)-r)copy(this.#e.subarray(this.#t),this.#e);else{if(s+e>MAX_SIZE)throw new Error("The buffer cannot be grown beyond the maximum size.");{const n=new Uint8Array(Math.min(2*s+e,MAX_SIZE));copy(this.#e.subarray(this.#t),n),this.#e=n}}return this.#t=0,this.#r(Math.min(r+e,MAX_SIZE)),r}grow(e){if(e<0)throw Error("Buffer.grow: negative count");const r=this.#n(e);this.#r(r)}async readFrom(e){let r=0;const i=new Uint8Array(MIN_READ);for(;;){const s=this.capacity-this.length<MIN_READ,n=s?i:new Uint8Array(this.#e.buffer,this.length),o=await e.read(n);if(o===null)return r;s?this.writeSync(n.subarray(0,o)):this.#r(this.length+o),r+=o}}readFromSync(e){let r=0;const i=new Uint8Array(MIN_READ);for(;;){const s=this.capacity-this.length<MIN_READ,n=s?i:new Uint8Array(this.#e.buffer,this.length),o=e.readSync(n);if(o===null)return r;s?this.writeSync(n.subarray(0,o)):this.#r(this.length+o),r+=o}}}class BytesList{len=0;chunks=[];constructor(){}size(){return this.len}add(e,r=0,i=e.byteLength){e.byteLength===0||i-r==0||(checkRange(r,i,e.byteLength),this.chunks.push({value:e,end:i,start:r,offset:this.len}),this.len+=i-r)}shift(e){if(e===0)return;if(this.len<=e){this.chunks=[],this.len=0;return}const r=this.getChunkIndex(e);this.chunks.splice(0,r);const[i]=this.chunks;if(i){const n=e-i.offset;i.start+=n}let s=0;for(const n of this.chunks)n.offset=s,s+=n.end-n.start;this.len=s}getChunkIndex(e){let r=this.chunks.length,i=0;for(;;){const s=i+Math.floor((r-i)/2);if(s<0||this.chunks.length<=s)return-1;const{offset:n,start:o,end:a}=this.chunks[s],h=a-o;if(n<=e&&e<n+h)return s;n+h<=e?i=s+1:r=s-1}}get(e){if(e<0||this.len<=e)throw new Error("out of range");const r=this.getChunkIndex(e),{value:i,offset:s,start:n}=this.chunks[r];return i[n+e-s]}*iterator(e=0){const r=this.getChunkIndex(e);if(r<0)return;const i=this.chunks[r];let s=e-i.offset;for(let n=r;n<this.chunks.length;n++){const o=this.chunks[n];for(let a=o.start+s;a<o.end;a++)yield o.value[a];s=0}}slice(e,r=this.len){if(r===e)return new Uint8Array;checkRange(e,r,this.len);const i=new Uint8Array(r-e),s=this.getChunkIndex(e),n=this.getChunkIndex(r-1);let o=0;for(let l=s;l<n;l++){const c=this.chunks[l],f=c.end-c.start;i.set(c.value.subarray(c.start,c.end),o),o+=f}const a=this.chunks[n],h=r-e-o;return i.set(a.value.subarray(a.start,a.start+h),o),i}concat(){const e=new Uint8Array(this.len);let r=0;for(const{value:i,start:s,end:n}of this.chunks)e.set(i.subarray(s,n),r),r+=n-s;return e}}function checkRange(t,e,r){if(t<0||r<t||e<0||r<e||e<t)throw new Error("invalid range")}const{Deno:Deno1}=globalThis;typeof Deno1?.noColor=="boolean"&&Deno1.noColor,new RegExp(["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|"),"g");var DiffType;(function(t){t.removed="removed",t.common="common",t.added="added"})(DiffType||(DiffType={}));class AssertionError extends Error{name="AssertionError";constructor(e){super(e)}}function assert2(t,e=""){if(!t)throw new AssertionError(e)}const DEFAULT_BUFFER_SIZE=32*1024;async function readAll(t){const e=new Buffer;return await e.readFrom(t),e.bytes()}function readAllSync(t){const e=new Buffer;return e.readFromSync(t),e.bytes()}async function readRange(t,e){let r=e.end-e.start+1;assert2(r>0,"Invalid byte range was passed."),await t.seek(e.start,Deno.SeekMode.Start);const i=new Uint8Array(r);let s=0;for(;r;){const n=new Uint8Array(Math.min(r,DEFAULT_BUFFER_SIZE)),o=await t.read(n);assert2(o!==null,"Unexpected EOF reach while reading a range."),assert2(o>0,"Unexpected read of 0 bytes while reading a range."),copy(n,i,s),s+=o,r-=o,assert2(r>=0,"Unexpected length remaining after reading range.")}return i}function readRangeSync(t,e){let r=e.end-e.start+1;assert2(r>0,"Invalid byte range was passed."),t.seekSync(e.start,Deno.SeekMode.Start);const i=new Uint8Array(r);let s=0;for(;r;){const n=new Uint8Array(Math.min(r,DEFAULT_BUFFER_SIZE)),o=t.readSync(n);assert2(o!==null,"Unexpected EOF reach while reading a range."),assert2(o>0,"Unexpected read of 0 bytes while reading a range."),copy(n,i,s),s+=o,r-=o,assert2(r>=0,"Unexpected length remaining after reading range.")}return i}async function writeAll(t,e){let r=0;for(;r<e.length;)r+=await t.write(e.subarray(r))}function writeAllSync(t,e){let r=0;for(;r<e.length;)r+=t.writeSync(e.subarray(r))}async function*iter(t,e){const r=e?.bufSize??DEFAULT_BUFFER_SIZE,i=new Uint8Array(r);for(;;){const s=await t.read(i);if(s===null)break;yield i.subarray(0,s)}}function*iterSync(t,e){const r=e?.bufSize??DEFAULT_BUFFER_SIZE,i=new Uint8Array(r);for(;;){const s=t.readSync(i);if(s===null)break;yield i.subarray(0,s)}}async function copy1(t,e,r){let i=0;const s=r?.bufSize??DEFAULT_BUFFER_SIZE,n=new Uint8Array(s);let o=!1;for(;o===!1;){const a=await t.read(n);if(a===null)o=!0;else{let h=0;for(;h<a;)h+=await e.write(n.subarray(h,a));i+=h}}return i}const DEFAULT_BUF_SIZE=4096,MIN_BUF_SIZE=16,CR="\r".charCodeAt(0),LF=`
`.charCodeAt(0);class BufferFullError extends Error{partial;name="BufferFullError";constructor(e){super("Buffer full");this.partial=e}}class PartialReadError extends Error{name="PartialReadError";partial;constructor(){super("Encountered UnexpectedEof, data only partially read")}}class BufReader{buf;rd;r=0;w=0;eof=!1;static create(e,r=4096){return e instanceof BufReader?e:new BufReader(e,r)}constructor(e,r=4096){r<16&&(r=MIN_BUF_SIZE),this._reset(new Uint8Array(r),e)}size(){return this.buf.byteLength}buffered(){return this.w-this.r}async _fill(){if(this.r>0&&(this.buf.copyWithin(0,this.r,this.w),this.w-=this.r,this.r=0),this.w>=this.buf.byteLength)throw Error("bufio: tried to fill full buffer");for(let e=100;e>0;e--){const r=await this.rd.read(this.buf.subarray(this.w));if(r===null){this.eof=!0;return}if(assert1(r>=0,"negative read"),this.w+=r,r>0)return}throw new Error(`No progress after ${100} read() calls`)}reset(e){this._reset(this.buf,e)}_reset(e,r){this.buf=e,this.rd=r,this.eof=!1}async read(e){let r=e.byteLength;if(e.byteLength===0)return r;if(this.r===this.w){if(e.byteLength>=this.buf.byteLength){const s=await this.rd.read(e);return assert1((s??0)>=0,"negative read"),s}if(this.r=0,this.w=0,r=await this.rd.read(this.buf),r===0||r===null)return r;assert1(r>=0,"negative read"),this.w+=r}const i=copy(this.buf.subarray(this.r,this.w),e,0);return this.r+=i,i}async readFull(e){let r=0;for(;r<e.length;)try{const i=await this.read(e.subarray(r));if(i===null){if(r===0)return null;throw new PartialReadError}r+=i}catch(i){if(i instanceof PartialReadError)i.partial=e.subarray(0,r);else if(i instanceof Error){const s=new PartialReadError;throw s.partial=e.subarray(0,r),s.stack=i.stack,s.message=i.message,s.cause=i.cause,i}throw i}return e}async readByte(){for(;this.r===this.w;){if(this.eof)return null;await this._fill()}const e=this.buf[this.r];return this.r++,e}async readString(e){if(e.length!==1)throw new Error("Delimiter should be a single character");const r=await this.readSlice(e.charCodeAt(0));return r===null?null:new TextDecoder().decode(r)}async readLine(){let e=null;try{e=await this.readSlice(LF)}catch(r){if(r instanceof Deno.errors.BadResource)throw r;let i;if(r instanceof PartialReadError&&(i=r.partial,assert1(i instanceof Uint8Array,"bufio: caught error from `readSlice()` without `partial` property")),!(r instanceof BufferFullError))throw r;if(!this.eof&&i&&i.byteLength>0&&i[i.byteLength-1]===CR&&(assert1(this.r>0,"bufio: tried to rewind past start of buffer"),this.r--,i=i.subarray(0,i.byteLength-1)),i)return{line:i,more:!this.eof}}if(e===null)return null;if(e.byteLength===0)return{line:e,more:!1};if(e[e.byteLength-1]==LF){let r=1;e.byteLength>1&&e[e.byteLength-2]===CR&&(r=2),e=e.subarray(0,e.byteLength-r)}return{line:e,more:!1}}async readSlice(e){let r=0,i;for(;;){let s=this.buf.subarray(this.r+r,this.w).indexOf(e);if(s>=0){s+=r,i=this.buf.subarray(this.r,this.r+s+1),this.r+=s+1;break}if(this.eof){if(this.r===this.w)return null;i=this.buf.subarray(this.r,this.w),this.r=this.w;break}if(this.buffered()>=this.buf.byteLength){this.r=this.w;const n=this.buf,o=this.buf.slice(0);throw this.buf=o,new BufferFullError(n)}r=this.w-this.r;try{await this._fill()}catch(n){if(n instanceof PartialReadError)n.partial=i;else if(n instanceof Error){const o=new PartialReadError;throw o.partial=i,o.stack=n.stack,o.message=n.message,o.cause=n.cause,n}throw n}}return i}async peek(e){if(e<0)throw Error("negative count");let r=this.w-this.r;for(;r<e&&r<this.buf.byteLength&&!this.eof;){try{await this._fill()}catch(i){if(i instanceof PartialReadError)i.partial=this.buf.subarray(this.r,this.w);else if(i instanceof Error){const s=new PartialReadError;throw s.partial=this.buf.subarray(this.r,this.w),s.stack=i.stack,s.message=i.message,s.cause=i.cause,i}throw i}r=this.w-this.r}if(r===0&&this.eof)return null;if(r<e&&this.eof)return this.buf.subarray(this.r,this.r+r);if(r<e)throw new BufferFullError(this.buf.subarray(this.r,this.w));return this.buf.subarray(this.r,this.r+e)}}class AbstractBufBase{buf;usedBufferBytes=0;err=null;size(){return this.buf.byteLength}available(){return this.buf.byteLength-this.usedBufferBytes}buffered(){return this.usedBufferBytes}}class BufWriter extends AbstractBufBase{writer;static create(e,r=4096){return e instanceof BufWriter?e:new BufWriter(e,r)}constructor(e,r=4096){super();this.writer=e,r<=0&&(r=DEFAULT_BUF_SIZE),this.buf=new Uint8Array(r)}reset(e){this.err=null,this.usedBufferBytes=0,this.writer=e}async flush(){if(this.err!==null)throw this.err;if(this.usedBufferBytes!==0){try{await writeAll(this.writer,this.buf.subarray(0,this.usedBufferBytes))}catch(e){throw e instanceof Error&&(this.err=e),e}this.buf=new Uint8Array(this.buf.length),this.usedBufferBytes=0}}async write(e){if(this.err!==null)throw this.err;if(e.length===0)return 0;let r=0,i=0;for(;e.byteLength>this.available();){if(this.buffered()===0)try{i=await this.writer.write(e)}catch(s){throw s instanceof Error&&(this.err=s),s}else i=copy(e,this.buf,this.usedBufferBytes),this.usedBufferBytes+=i,await this.flush();r+=i,e=e.subarray(i)}return i=copy(e,this.buf,this.usedBufferBytes),this.usedBufferBytes+=i,r+=i,r}}class BufWriterSync extends AbstractBufBase{writer;static create(e,r=4096){return e instanceof BufWriterSync?e:new BufWriterSync(e,r)}constructor(e,r=4096){super();this.writer=e,r<=0&&(r=DEFAULT_BUF_SIZE),this.buf=new Uint8Array(r)}reset(e){this.err=null,this.usedBufferBytes=0,this.writer=e}flush(){if(this.err!==null)throw this.err;if(this.usedBufferBytes!==0){try{writeAllSync(this.writer,this.buf.subarray(0,this.usedBufferBytes))}catch(e){throw e instanceof Error&&(this.err=e),e}this.buf=new Uint8Array(this.buf.length),this.usedBufferBytes=0}}writeSync(e){if(this.err!==null)throw this.err;if(e.length===0)return 0;let r=0,i=0;for(;e.byteLength>this.available();){if(this.buffered()===0)try{i=this.writer.writeSync(e)}catch(s){throw s instanceof Error&&(this.err=s),s}else i=copy(e,this.buf,this.usedBufferBytes),this.usedBufferBytes+=i,this.flush();r+=i,e=e.subarray(i)}return i=copy(e,this.buf,this.usedBufferBytes),this.usedBufferBytes+=i,r+=i,r}}function createLPS(t){const e=new Uint8Array(t.length);e[0]=0;let r=0,i=1;for(;i<e.length;)t[i]==t[r]?(r++,e[i]=r,i++):r===0?(e[i]=0,i++):r=e[r-1];return e}async function*readDelim(t,e){const r=e.length,i=createLPS(e),s=new BytesList,n=Math.max(1024,r+1);let o=0,a=0;for(;;){const h=new Uint8Array(n),l=await t.read(h);if(l===null){yield s.concat();return}else if(l<0)return;s.add(h,0,l);let c=0;for(;o<s.size();)if(h[c]===e[a]){if(o++,c++,a++,a===r){const f=o-r;yield s.slice(0,f),s.shift(o),o=0,a=0}}else a===0?(o++,c++):a=i[a-1]}}async function*readStringDelim(t,e,r){const i=new TextEncoder,s=new TextDecoder(r?.encoding,r);for await(const n of readDelim(t,i.encode(e)))yield s.decode(n)}async function*readLines(t,e){const r=new BufReader(t);let i=[];const s=new TextDecoder(e?.encoding,e);for(;;){const n=await r.readLine();if(!n){i.length>0&&(yield s.decode(concat(...i)));break}i.push(n.line),n.more||(yield s.decode(concat(...i)),i=[])}}const DEFAULT_BUFFER_SIZE1=32*1024;async function copyN(t,e,r){let i=0,s=new Uint8Array(DEFAULT_BUFFER_SIZE1);for(;i<r;){r-i<DEFAULT_BUFFER_SIZE1&&(s=new Uint8Array(r-i));const n=await t.read(s),o=n??0;if(i+=o,o>0){let a=0;for(;a<o;)a+=await e.write(s.slice(a,o));assert1(a===o,"could not write")}if(n===null)break}return i}async function readShort(t){const e=await t.readByte();if(e===null)return null;const r=await t.readByte();if(r===null)throw new Deno.errors.UnexpectedEof;return e<<8|r}async function readInt(t){const e=await readShort(t);if(e===null)return null;const r=await readShort(t);if(r===null)throw new Deno.errors.UnexpectedEof;return e<<16|r}const MAX_SAFE_INTEGER=BigInt(Number.MAX_SAFE_INTEGER);async function readLong(t){const e=await readInt(t);if(e===null)return null;const r=await readInt(t);if(r===null)throw new Deno.errors.UnexpectedEof;const i=BigInt(e)<<32n|BigInt(r);if(i>MAX_SAFE_INTEGER)throw new RangeError("Long value too big to be represented as a JavaScript number.");return Number(i)}function sliceLongToBytes(t,e=new Array(8)){let r=BigInt(t);for(let i=0;i<8;i++)e[7-i]=Number(r&255n),r>>=8n;return e}class StringReader extends Buffer{constructor(e){super(new TextEncoder().encode(e).buffer)}}class MultiReader{readers;currentIndex=0;constructor(...e){this.readers=e}async read(e){const r=this.readers[this.currentIndex];if(!r)return null;const i=await r.read(e);return i===null?(this.currentIndex++,0):i}}class LimitedReader{reader;limit;constructor(e,r){this.reader=e,this.limit=r}async read(e){if(this.limit<=0)return null;e.length>this.limit&&(e=e.subarray(0,this.limit));const r=await this.reader.read(e);return r==null?null:(this.limit-=r,r)}}function isCloser(t){return typeof t=="object"&&t!=null&&"close"in t&&typeof t.close=="function"}function readerFromIterable(t){const e=t[Symbol.asyncIterator]?.()??t[Symbol.iterator]?.(),r=new Buffer;return{async read(i){if(r.length==0){const s=await e.next();return s.done?null:s.value.byteLength<=i.byteLength?(i.set(s.value),s.value.byteLength):(i.set(s.value.subarray(0,i.byteLength)),await writeAll(r,s.value.subarray(i.byteLength)),i.byteLength)}else{const s=await r.read(i);return s??this.read(i)}}}}function writerFromStreamWriter(t){return{async write(e){return await t.ready,await t.write(e),e.length}}}function readerFromStreamReader(t){const e=new Buffer;return{async read(r){if(e.empty()){const i=await t.read();if(i.done)return null;await writeAll(e,i.value)}return e.read(r)}}}function writableStreamFromWriter(t,e={}){const{autoClose:r=!0}=e;return new WritableStream({async write(i,s){try{await writeAll(t,i)}catch(n){s.error(n),isCloser(t)&&r&&t.close()}},close(){isCloser(t)&&r&&t.close()},abort(){isCloser(t)&&r&&t.close()}})}function readableStreamFromIterable(t){const e=t[Symbol.asyncIterator]?.()??t[Symbol.iterator]?.();return new ReadableStream({async pull(r){const{value:i,done:s}=await e.next();s?r.close():r.enqueue(i)},async cancel(r){if(typeof e.throw=="function")try{await e.throw(r)}catch{}}})}function readableStreamFromReader(t,e={}){const{autoClose:r=!0,chunkSize:i=16640,strategy:s}=e;return new ReadableStream({async pull(n){const o=new Uint8Array(i);try{const a=await t.read(o);if(a===null){isCloser(t)&&r&&t.close(),n.close();return}n.enqueue(o.subarray(0,a))}catch(a){n.error(a),isCloser(t)&&t.close()}},cancel(){isCloser(t)&&r&&t.close()}},s)}const decoder2=new TextDecoder;class StringWriter{base;chunks=[];byteLength=0;cache;constructor(e=""){this.base=e;const r=new TextEncoder().encode(e);this.chunks.push(r),this.byteLength+=r.byteLength}write(e){return Promise.resolve(this.writeSync(e))}writeSync(e){return this.chunks.push(e),this.byteLength+=e.byteLength,this.cache=void 0,e.byteLength}toString(){if(this.cache)return this.cache;const e=new Uint8Array(this.byteLength);let r=0;for(const i of this.chunks)e.set(i,r),r+=i.byteLength;return this.cache=decoder2.decode(e),this.cache}}const mod3={Buffer,BufferFullError,PartialReadError,BufReader,BufWriter,BufWriterSync,readDelim,readStringDelim,readLines,readAll,readAllSync,readRange,readRangeSync,writeAll,writeAllSync,iter,iterSync,copy:copy1,copyN,readShort,readInt,readLong,sliceLongToBytes,StringReader,MultiReader,LimitedReader,readerFromIterable,writerFromStreamWriter,readerFromStreamReader,writableStreamFromWriter,readableStreamFromIterable,readableStreamFromReader,StringWriter};function isRequestMessage(t){return Array.isArray(t)&&t.length===4&&t[0]===0&&typeof t[1]=="number"&&typeof t[2]=="string"&&Array.isArray(t[3])}function isResponseMessage(t){return Array.isArray(t)&&t.length===4&&t[0]===1&&typeof t[1]=="number"&&typeof t[2]!="undefined"&&typeof t[3]!="undefined"}function isNotificationMessage(t){return Array.isArray(t)&&t.length===3&&t[0]===2&&typeof t[1]=="string"&&Array.isArray(t[2])}class Indexer{#e;#t;constructor(e){if(e!=null&&e<2)throw new Error(`The attribute 'max' must be greater than 1 but ${e} has specified`);this.#e=e??Number.MAX_SAFE_INTEGER,this.#t=-1}next(){return this.#t>=this.#e&&(this.#t=-1),this.#t+=1,this.#t}}class TimeoutError extends Error{constructor(){super("the process didn't complete in time");this.name="TimeoutError"}}class ResponseWaiter{#e;#t;constructor(e=1e4){this.#e=new Map,this.#t=e}get waiterCount(){return this.#e.size}wait(e,r){let i=this.#e.get(e)?.response;if(!i){i=deferred2();const s=setTimeout(()=>{const n=this.#e.get(e)?.response;!n||(n.reject(new TimeoutError),this.#e.delete(e))},r??this.#t);this.#e.set(e,{timer:s,response:i})}return i}provide(e){const[r,i,s,n]=e,o=this.#e.get(i);if(!o)return!1;this.#e.delete(i);const{timer:a,response:h}=o;return clearTimeout(a),h.resolve(e),!0}}const MSGID_THRESHOLD=2**32;class Session{#e;#t;#i;#r;#n;#o;#s;dispatcher;constructor(e,r,i={},s={}){this.dispatcher=i,this.#e=new Indexer(MSGID_THRESHOLD),this.#t=new ResponseWaiter(s.responseTimeout),this.#i=e,this.#r=r,this.#o=!1,this.#s=deferred2(),this.#n=this.listen().catch(n=>{s.errorCallback?s.errorCallback(n):console.error(`Unexpected error occured in session: ${n}`)})}async send(e){await mod3.writeAll(this.#r,e)}async dispatch(e,...r){if(!Object.prototype.hasOwnProperty.call(this.dispatcher,e)){const i=Object.getOwnPropertyNames(this.dispatcher);throw new Error(`No method '${e}' exists in ${JSON.stringify(i)}`)}return await this.dispatcher[e].apply(this,r)}async handleRequest(e){const[r,i,s,n]=e,[o,a]=await(async()=>{let l=null,c=null;try{l=await this.dispatch(s,...n)}catch(f){c=f.stack??f.toString()}return[l,c]})(),h=[1,i,a,o];await this.send(encode1(h))}handleResponse(e){this.#t.provide(e)||console.warn("Unexpected response message received",e)}async handleNotification(e){const[r,i,s]=e;try{await this.dispatch(i,...s)}catch(n){console.error(n)}}async listen(){const e=decodeStream(mod3.iter(this.#i));try{for(;!this.#o;){const{done:r,value:i}=await Promise.race([this.#s,e.next()]);if(r)return;if(isRequestMessage(i))this.handleRequest(i);else if(isResponseMessage(i))this.handleResponse(i);else if(isNotificationMessage(i))this.handleNotification(i);else{console.warn(`Unexpected data received: ${i}`);continue}}}catch(r){if(r instanceof SessionClosedError||r instanceof Deno.errors.BadResource)return;throw r}}dispose(){this.close()}close(){this.#o=!0,this.#s.reject(new SessionClosedError)}waitClosed(){return this.#n}async call(e,...r){if(this.#o)throw new SessionClosedError;const i=this.#e.next(),s=[0,i,e,r],[n,o]=await Promise.race([this.#s,Promise.all([this.send(encode1(s)),this.#t.wait(i)])]),[a,h]=o.slice(2);if(a){const l=JSON.stringify(r),c=typeof a=="string"?a:JSON.stringify(a);throw new Error(`Failed to call '${e}' with ${l}: ${c}`)}return h}async notify(e,...r){if(this.#o)throw new SessionClosedError;const i=[2,e,r];await Promise.race([this.#s,this.send(encode1(i))])}clearDispatcher(){this.dispatcher={}}extendDispatcher(e){this.dispatcher={...this.dispatcher,...e}}}class SessionClosedError extends Error{constructor(){super("The session is closed");this.name="SessionClosedError"}}class DenoStdInternalError2 extends Error{constructor(e){super(e);this.name="DenoStdInternalError"}}function assert3(t,e=""){if(!t)throw new DenoStdInternalError2(e)}function concat1(...t){let e=0;for(const s of t)e+=s.length;const r=new Uint8Array(e);let i=0;for(const s of t)r.set(s,i),i+=s.length;return r}function copy2(t,e,r=0){r=Math.max(0,Math.min(r,e.byteLength));const i=e.byteLength-r;return t.byteLength>i&&(t=t.subarray(0,i)),e.set(t,r),t.byteLength}const MIN_READ1=32*1024,MAX_SIZE1=2**32-2;class Buffer1{#e;#t=0;constructor(e){this.#e=e===void 0?new Uint8Array(0):new Uint8Array(e)}bytes(e={copy:!0}){return e.copy===!1?this.#e.subarray(this.#t):this.#e.slice(this.#t)}empty(){return this.#e.byteLength<=this.#t}get length(){return this.#e.byteLength-this.#t}get capacity(){return this.#e.buffer.byteLength}truncate(e){if(e===0){this.reset();return}if(e<0||e>this.length)throw Error("bytes.Buffer: truncation out of range");this.#r(this.#t+e)}reset(){this.#r(0),this.#t=0}#i(e){const r=this.#e.byteLength;return e<=this.capacity-r?(this.#r(r+e),r):-1}#r(e){assert3(e<=this.#e.buffer.byteLength),this.#e=new Uint8Array(this.#e.buffer,0,e)}readSync(e){if(this.empty())return this.reset(),e.byteLength===0?0:null;const r=copy2(this.#e.subarray(this.#t),e);return this.#t+=r,r}read(e){const r=this.readSync(e);return Promise.resolve(r)}writeSync(e){const r=this.#n(e.byteLength);return copy2(e,this.#e,r)}write(e){const r=this.writeSync(e);return Promise.resolve(r)}#n(e){const r=this.length;r===0&&this.#t!==0&&this.reset();const i=this.#i(e);if(i>=0)return i;const s=this.capacity;if(e<=Math.floor(s/2)-r)copy2(this.#e.subarray(this.#t),this.#e);else{if(s+e>MAX_SIZE1)throw new Error("The buffer cannot be grown beyond the maximum size.");{const n=new Uint8Array(Math.min(2*s+e,MAX_SIZE1));copy2(this.#e.subarray(this.#t),n),this.#e=n}}return this.#t=0,this.#r(Math.min(r+e,MAX_SIZE1)),r}grow(e){if(e<0)throw Error("Buffer.grow: negative count");const r=this.#n(e);this.#r(r)}async readFrom(e){let r=0;const i=new Uint8Array(MIN_READ1);for(;;){const s=this.capacity-this.length<MIN_READ1,n=s?i:new Uint8Array(this.#e.buffer,this.length),o=await e.read(n);if(o===null)return r;s?this.writeSync(n.subarray(0,o)):this.#r(this.length+o),r+=o}}readFromSync(e){let r=0;const i=new Uint8Array(MIN_READ1);for(;;){const s=this.capacity-this.length<MIN_READ1,n=s?i:new Uint8Array(this.#e.buffer,this.length),o=e.readSync(n);if(o===null)return r;s?this.writeSync(n.subarray(0,o)):this.#r(this.length+o),r+=o}}}class BytesList1{len=0;chunks=[];constructor(){}size(){return this.len}add(e,r=0,i=e.byteLength){e.byteLength===0||i-r==0||(checkRange1(r,i,e.byteLength),this.chunks.push({value:e,end:i,start:r,offset:this.len}),this.len+=i-r)}shift(e){if(e===0)return;if(this.len<=e){this.chunks=[],this.len=0;return}const r=this.getChunkIndex(e);this.chunks.splice(0,r);const[i]=this.chunks;if(i){const n=e-i.offset;i.start+=n}let s=0;for(const n of this.chunks)n.offset=s,s+=n.end-n.start;this.len=s}getChunkIndex(e){let r=this.chunks.length,i=0;for(;;){const s=i+Math.floor((r-i)/2);if(s<0||this.chunks.length<=s)return-1;const{offset:n,start:o,end:a}=this.chunks[s],h=a-o;if(n<=e&&e<n+h)return s;n+h<=e?i=s+1:r=s-1}}get(e){if(e<0||this.len<=e)throw new Error("out of range");const r=this.getChunkIndex(e),{value:i,offset:s,start:n}=this.chunks[r];return i[n+e-s]}*iterator(e=0){const r=this.getChunkIndex(e);if(r<0)return;const i=this.chunks[r];let s=e-i.offset;for(let n=r;n<this.chunks.length;n++){const o=this.chunks[n];for(let a=o.start+s;a<o.end;a++)yield o.value[a];s=0}}slice(e,r=this.len){if(r===e)return new Uint8Array;checkRange1(e,r,this.len);const i=new Uint8Array(r-e),s=this.getChunkIndex(e),n=this.getChunkIndex(r-1);let o=0;for(let l=s;l<n;l++){const c=this.chunks[l],f=c.end-c.start;i.set(c.value.subarray(c.start,c.end),o),o+=f}const a=this.chunks[n],h=r-e-o;return i.set(a.value.subarray(a.start,a.start+h),o),i}concat(){const e=new Uint8Array(this.len);let r=0;for(const{value:i,start:s,end:n}of this.chunks)e.set(i.subarray(s,n),r),r+=n-s;return e}}function checkRange1(t,e,r){if(t<0||r<t||e<0||r<e||e<t)throw new Error("invalid range")}const{Deno:Deno2}=globalThis;typeof Deno2?.noColor=="boolean"&&Deno2.noColor,new RegExp(["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|"),"g");var DiffType1;(function(t){t.removed="removed",t.common="common",t.added="added"})(DiffType1||(DiffType1={}));class AssertionError1 extends Error{constructor(e){super(e);this.name="AssertionError"}}function assert4(t,e=""){if(!t)throw new AssertionError1(e)}const DEFAULT_BUFFER_SIZE2=32*1024;async function readAll1(t){const e=new Buffer1;return await e.readFrom(t),e.bytes()}function readAllSync1(t){const e=new Buffer1;return e.readFromSync(t),e.bytes()}async function readRange1(t,e){let r=e.end-e.start+1;assert4(r>0,"Invalid byte range was passed."),await t.seek(e.start,Deno.SeekMode.Start);const i=new Uint8Array(r);let s=0;for(;r;){const n=new Uint8Array(Math.min(r,DEFAULT_BUFFER_SIZE2)),o=await t.read(n);assert4(o!==null,"Unexpected EOF reach while reading a range."),assert4(o>0,"Unexpected read of 0 bytes while reading a range."),copy2(n,i,s),s+=o,r-=o,assert4(r>=0,"Unexpected length remaining after reading range.")}return i}function readRangeSync1(t,e){let r=e.end-e.start+1;assert4(r>0,"Invalid byte range was passed."),t.seekSync(e.start,Deno.SeekMode.Start);const i=new Uint8Array(r);let s=0;for(;r;){const n=new Uint8Array(Math.min(r,DEFAULT_BUFFER_SIZE2)),o=t.readSync(n);assert4(o!==null,"Unexpected EOF reach while reading a range."),assert4(o>0,"Unexpected read of 0 bytes while reading a range."),copy2(n,i,s),s+=o,r-=o,assert4(r>=0,"Unexpected length remaining after reading range.")}return i}async function writeAll1(t,e){let r=0;for(;r<e.length;)r+=await t.write(e.subarray(r))}function writeAllSync1(t,e){let r=0;for(;r<e.length;)r+=t.writeSync(e.subarray(r))}async function*iter1(t,e){const r=e?.bufSize??DEFAULT_BUFFER_SIZE2,i=new Uint8Array(r);for(;;){const s=await t.read(i);if(s===null)break;yield i.subarray(0,s)}}function*iterSync1(t,e){const r=e?.bufSize??DEFAULT_BUFFER_SIZE2,i=new Uint8Array(r);for(;;){const s=t.readSync(i);if(s===null)break;yield i.subarray(0,s)}}async function copy3(t,e,r){let i=0;const s=r?.bufSize??DEFAULT_BUFFER_SIZE2,n=new Uint8Array(s);let o=!1;for(;o===!1;){const a=await t.read(n);if(a===null)o=!0;else{let h=0;for(;h<a;)h+=await e.write(n.subarray(h,a));i+=h}}return i}const DEFAULT_BUF_SIZE1=4096,MIN_BUF_SIZE1=16,CR1="\r".charCodeAt(0),LF1=`
`.charCodeAt(0);class BufferFullError1 extends Error{partial;name="BufferFullError";constructor(e){super("Buffer full");this.partial=e}}class PartialReadError1 extends Error{name="PartialReadError";partial;constructor(){super("Encountered UnexpectedEof, data only partially read")}}class BufReader1{buf;rd;r=0;w=0;eof=!1;static create(e,r=4096){return e instanceof BufReader1?e:new BufReader1(e,r)}constructor(e,r=4096){r<16&&(r=MIN_BUF_SIZE1),this._reset(new Uint8Array(r),e)}size(){return this.buf.byteLength}buffered(){return this.w-this.r}async _fill(){if(this.r>0&&(this.buf.copyWithin(0,this.r,this.w),this.w-=this.r,this.r=0),this.w>=this.buf.byteLength)throw Error("bufio: tried to fill full buffer");for(let e=100;e>0;e--){const r=await this.rd.read(this.buf.subarray(this.w));if(r===null){this.eof=!0;return}if(assert3(r>=0,"negative read"),this.w+=r,r>0)return}throw new Error(`No progress after ${100} read() calls`)}reset(e){this._reset(this.buf,e)}_reset(e,r){this.buf=e,this.rd=r,this.eof=!1}async read(e){let r=e.byteLength;if(e.byteLength===0)return r;if(this.r===this.w){if(e.byteLength>=this.buf.byteLength){const s=await this.rd.read(e);return assert3((s??0)>=0,"negative read"),s}if(this.r=0,this.w=0,r=await this.rd.read(this.buf),r===0||r===null)return r;assert3(r>=0,"negative read"),this.w+=r}const i=copy2(this.buf.subarray(this.r,this.w),e,0);return this.r+=i,i}async readFull(e){let r=0;for(;r<e.length;)try{const i=await this.read(e.subarray(r));if(i===null){if(r===0)return null;throw new PartialReadError1}r+=i}catch(i){throw i.partial=e.subarray(0,r),i}return e}async readByte(){for(;this.r===this.w;){if(this.eof)return null;await this._fill()}const e=this.buf[this.r];return this.r++,e}async readString(e){if(e.length!==1)throw new Error("Delimiter should be a single character");const r=await this.readSlice(e.charCodeAt(0));return r===null?null:new TextDecoder().decode(r)}async readLine(){let e;try{e=await this.readSlice(LF1)}catch(r){if(r instanceof Deno.errors.BadResource)throw r;let{partial:i}=r;if(assert3(i instanceof Uint8Array,"bufio: caught error from `readSlice()` without `partial` property"),!(r instanceof BufferFullError1))throw r;return!this.eof&&i.byteLength>0&&i[i.byteLength-1]===CR1&&(assert3(this.r>0,"bufio: tried to rewind past start of buffer"),this.r--,i=i.subarray(0,i.byteLength-1)),{line:i,more:!this.eof}}if(e===null)return null;if(e.byteLength===0)return{line:e,more:!1};if(e[e.byteLength-1]==LF1){let r=1;e.byteLength>1&&e[e.byteLength-2]===CR1&&(r=2),e=e.subarray(0,e.byteLength-r)}return{line:e,more:!1}}async readSlice(e){let r=0,i;for(;;){let s=this.buf.subarray(this.r+r,this.w).indexOf(e);if(s>=0){s+=r,i=this.buf.subarray(this.r,this.r+s+1),this.r+=s+1;break}if(this.eof){if(this.r===this.w)return null;i=this.buf.subarray(this.r,this.w),this.r=this.w;break}if(this.buffered()>=this.buf.byteLength){this.r=this.w;const n=this.buf,o=this.buf.slice(0);throw this.buf=o,new BufferFullError1(n)}r=this.w-this.r;try{await this._fill()}catch(n){throw n.partial=i,n}}return i}async peek(e){if(e<0)throw Error("negative count");let r=this.w-this.r;for(;r<e&&r<this.buf.byteLength&&!this.eof;){try{await this._fill()}catch(i){throw i.partial=this.buf.subarray(this.r,this.w),i}r=this.w-this.r}if(r===0&&this.eof)return null;if(r<e&&this.eof)return this.buf.subarray(this.r,this.r+r);if(r<e)throw new BufferFullError1(this.buf.subarray(this.r,this.w));return this.buf.subarray(this.r,this.r+e)}}class AbstractBufBase1{buf;usedBufferBytes=0;err=null;size(){return this.buf.byteLength}available(){return this.buf.byteLength-this.usedBufferBytes}buffered(){return this.usedBufferBytes}}class BufWriter1 extends AbstractBufBase1{writer;static create(e,r=4096){return e instanceof BufWriter1?e:new BufWriter1(e,r)}constructor(e,r=4096){super();this.writer=e,r<=0&&(r=DEFAULT_BUF_SIZE1),this.buf=new Uint8Array(r)}reset(e){this.err=null,this.usedBufferBytes=0,this.writer=e}async flush(){if(this.err!==null)throw this.err;if(this.usedBufferBytes!==0){try{await writeAll1(this.writer,this.buf.subarray(0,this.usedBufferBytes))}catch(e){throw this.err=e,e}this.buf=new Uint8Array(this.buf.length),this.usedBufferBytes=0}}async write(e){if(this.err!==null)throw this.err;if(e.length===0)return 0;let r=0,i=0;for(;e.byteLength>this.available();){if(this.buffered()===0)try{i=await this.writer.write(e)}catch(s){throw this.err=s,s}else i=copy2(e,this.buf,this.usedBufferBytes),this.usedBufferBytes+=i,await this.flush();r+=i,e=e.subarray(i)}return i=copy2(e,this.buf,this.usedBufferBytes),this.usedBufferBytes+=i,r+=i,r}}class BufWriterSync1 extends AbstractBufBase1{writer;static create(e,r=4096){return e instanceof BufWriterSync1?e:new BufWriterSync1(e,r)}constructor(e,r=4096){super();this.writer=e,r<=0&&(r=DEFAULT_BUF_SIZE1),this.buf=new Uint8Array(r)}reset(e){this.err=null,this.usedBufferBytes=0,this.writer=e}flush(){if(this.err!==null)throw this.err;if(this.usedBufferBytes!==0){try{writeAllSync1(this.writer,this.buf.subarray(0,this.usedBufferBytes))}catch(e){throw this.err=e,e}this.buf=new Uint8Array(this.buf.length),this.usedBufferBytes=0}}writeSync(e){if(this.err!==null)throw this.err;if(e.length===0)return 0;let r=0,i=0;for(;e.byteLength>this.available();){if(this.buffered()===0)try{i=this.writer.writeSync(e)}catch(s){throw this.err=s,s}else i=copy2(e,this.buf,this.usedBufferBytes),this.usedBufferBytes+=i,this.flush();r+=i,e=e.subarray(i)}return i=copy2(e,this.buf,this.usedBufferBytes),this.usedBufferBytes+=i,r+=i,r}}function createLPS1(t){const e=new Uint8Array(t.length);e[0]=0;let r=0,i=1;for(;i<e.length;)t[i]==t[r]?(r++,e[i]=r,i++):r===0?(e[i]=0,i++):r=e[r-1];return e}async function*readDelim1(t,e){const r=e.length,i=createLPS1(e),s=new BytesList1,n=Math.max(1024,r+1);let o=0,a=0;for(;;){const h=new Uint8Array(n),l=await t.read(h);if(l===null){yield s.concat();return}else if(l<0)return;s.add(h,0,l);let c=0;for(;o<s.size();)if(h[c]===e[a]){if(o++,c++,a++,a===r){const f=o-r;yield s.slice(0,f),s.shift(o),o=0,a=0}}else a===0?(o++,c++):a=i[a-1]}}async function*readStringDelim1(t,e,r){const i=new TextEncoder,s=new TextDecoder(r?.encoding,r);for await(const n of readDelim1(t,i.encode(e)))yield s.decode(n)}async function*readLines1(t,e){const r=new BufReader1(t);let i=[];const s=new TextDecoder(e?.encoding,e);for(;;){const n=await r.readLine();if(!n){i.length>0&&(yield s.decode(concat1(...i)));break}i.push(n.line),n.more||(yield s.decode(concat1(...i)),i=[])}}const DEFAULT_BUFFER_SIZE3=32*1024;async function copyN1(t,e,r){let i=0,s=new Uint8Array(DEFAULT_BUFFER_SIZE3);for(;i<r;){r-i<DEFAULT_BUFFER_SIZE3&&(s=new Uint8Array(r-i));const n=await t.read(s),o=n??0;if(i+=o,o>0){let a=0;for(;a<o;)a+=await e.write(s.slice(a,o));assert3(a===o,"could not write")}if(n===null)break}return i}async function readShort1(t){const e=await t.readByte();if(e===null)return null;const r=await t.readByte();if(r===null)throw new Deno.errors.UnexpectedEof;return e<<8|r}async function readInt1(t){const e=await readShort1(t);if(e===null)return null;const r=await readShort1(t);if(r===null)throw new Deno.errors.UnexpectedEof;return e<<16|r}const MAX_SAFE_INTEGER1=BigInt(Number.MAX_SAFE_INTEGER);async function readLong1(t){const e=await readInt1(t);if(e===null)return null;const r=await readInt1(t);if(r===null)throw new Deno.errors.UnexpectedEof;const i=BigInt(e)<<32n|BigInt(r);if(i>MAX_SAFE_INTEGER1)throw new RangeError("Long value too big to be represented as a JavaScript number.");return Number(i)}function sliceLongToBytes1(t,e=new Array(8)){let r=BigInt(t);for(let i=0;i<8;i++)e[7-i]=Number(r&255n),r>>=8n;return e}class StringReader1 extends Buffer1{constructor(e){super(new TextEncoder().encode(e).buffer)}}class MultiReader1{readers;currentIndex=0;constructor(...e){this.readers=e}async read(e){const r=this.readers[this.currentIndex];if(!r)return null;const i=await r.read(e);return i===null?(this.currentIndex++,0):i}}class LimitedReader1{reader;limit;constructor(e,r){this.reader=e,this.limit=r}async read(e){if(this.limit<=0)return null;e.length>this.limit&&(e=e.subarray(0,this.limit));const r=await this.reader.read(e);return r==null?null:(this.limit-=r,r)}}function isCloser1(t){return typeof t=="object"&&t!=null&&"close"in t&&typeof t.close=="function"}function readerFromIterable1(t){const e=t[Symbol.asyncIterator]?.()??t[Symbol.iterator]?.(),r=new Buffer1;return{async read(i){if(r.length==0){const s=await e.next();return s.done?null:s.value.byteLength<=i.byteLength?(i.set(s.value),s.value.byteLength):(i.set(s.value.subarray(0,i.byteLength)),await writeAll1(r,s.value.subarray(i.byteLength)),i.byteLength)}else{const s=await r.read(i);return s??this.read(i)}}}}function writerFromStreamWriter1(t){return{async write(e){return await t.ready,await t.write(e),e.length}}}function readerFromStreamReader1(t){const e=new Buffer1;return{async read(r){if(e.empty()){const i=await t.read();if(i.done)return null;await writeAll1(e,i.value)}return e.read(r)}}}function writableStreamFromWriter1(t,e={}){const{autoClose:r=!0}=e;return new WritableStream({async write(i,s){try{await writeAll1(t,i)}catch(n){s.error(n),isCloser1(t)&&r&&t.close()}},close(){isCloser1(t)&&r&&t.close()},abort(){isCloser1(t)&&r&&t.close()}})}function readableStreamFromIterable1(t){const e=t[Symbol.asyncIterator]?.()??t[Symbol.iterator]?.();return new ReadableStream({async pull(r){const{value:i,done:s}=await e.next();s?r.close():r.enqueue(i)}})}function readableStreamFromReader1(t,e={}){const{autoClose:r=!0,chunkSize:i=16640,strategy:s}=e;return new ReadableStream({async pull(n){const o=new Uint8Array(i);try{const a=await t.read(o);if(a===null){isCloser1(t)&&r&&t.close(),n.close();return}n.enqueue(o.subarray(0,a))}catch(a){n.error(a),isCloser1(t)&&t.close()}},cancel(){isCloser1(t)&&r&&t.close()}},s)}const decoder1=new TextDecoder;class StringWriter1{base;chunks=[];byteLength=0;cache;constructor(e=""){this.base=e;const r=new TextEncoder().encode(e);this.chunks.push(r),this.byteLength+=r.byteLength}write(e){return Promise.resolve(this.writeSync(e))}writeSync(e){return this.chunks.push(e),this.byteLength+=e.byteLength,this.cache=void 0,e.byteLength}toString(){if(this.cache)return this.cache;const e=new Uint8Array(this.byteLength);let r=0;for(const i of this.chunks)e.set(i,r),r+=i.byteLength;return this.cache=decoder1.decode(e),this.cache}}const mod4={Buffer:Buffer1,BufferFullError:BufferFullError1,PartialReadError:PartialReadError1,BufReader:BufReader1,BufWriter:BufWriter1,BufWriterSync:BufWriterSync1,readDelim:readDelim1,readStringDelim:readStringDelim1,readLines:readLines1,readAll:readAll1,readAllSync:readAllSync1,readRange:readRange1,readRangeSync:readRangeSync1,writeAll:writeAll1,writeAllSync:writeAllSync1,iter:iter1,iterSync:iterSync1,copy:copy3,copyN:copyN1,readShort:readShort1,readInt:readInt1,readLong:readLong1,sliceLongToBytes:sliceLongToBytes1,StringReader:StringReader1,MultiReader:MultiReader1,LimitedReader:LimitedReader1,readerFromIterable:readerFromIterable1,writerFromStreamWriter:writerFromStreamWriter1,readerFromStreamReader:readerFromStreamReader1,writableStreamFromWriter:writableStreamFromWriter1,readableStreamFromIterable:readableStreamFromIterable1,readableStreamFromReader:readableStreamFromReader1,StringWriter:StringWriter1};function deferred3(){let t,e="pending";const r=new Promise((i,s)=>{t={async resolve(n){await n,e="fulfilled",i(n)},reject(n){e="rejected",s(n)}}});return Object.defineProperty(r,"state",{get:()=>e}),Object.assign(r,t)}var charset;(function(t){t[t.BACKSPACE=8]="BACKSPACE",t[t.FORM_FEED=12]="FORM_FEED",t[t.NEWLINE=10]="NEWLINE",t[t.CARRIAGE_RETURN=13]="CARRIAGE_RETURN",t[t.TAB=9]="TAB",t[t.SPACE=32]="SPACE",t[t.EXCLAMATION_MARK=33]="EXCLAMATION_MARK",t[t.QUOTATION_MARK=34]="QUOTATION_MARK",t[t.NUMBER_SIGN=35]="NUMBER_SIGN",t[t.DOLLAR_SIGN=36]="DOLLAR_SIGN",t[t.PERCENT_SIGN=37]="PERCENT_SIGN",t[t.AMPERSAND=38]="AMPERSAND",t[t.APOSTROPHE=39]="APOSTROPHE",t[t.LEFT_PARENTHESIS=40]="LEFT_PARENTHESIS",t[t.RIGHT_PARENTHESIS=41]="RIGHT_PARENTHESIS",t[t.ASTERISK=42]="ASTERISK",t[t.PLUS_SIGN=43]="PLUS_SIGN",t[t.COMMA=44]="COMMA",t[t.HYPHEN_MINUS=45]="HYPHEN_MINUS",t[t.FULL_STOP=46]="FULL_STOP",t[t.SOLIDUS=47]="SOLIDUS",t[t.DIGIT_ZERO=48]="DIGIT_ZERO",t[t.DIGIT_ONE=49]="DIGIT_ONE",t[t.DIGIT_TWO=50]="DIGIT_TWO",t[t.DIGIT_THREE=51]="DIGIT_THREE",t[t.DIGIT_FOUR=52]="DIGIT_FOUR",t[t.DIGIT_FIVE=53]="DIGIT_FIVE",t[t.DIGIT_SIX=54]="DIGIT_SIX",t[t.DIGIT_SEVEN=55]="DIGIT_SEVEN",t[t.DIGIT_EIGHT=56]="DIGIT_EIGHT",t[t.DIGIT_NINE=57]="DIGIT_NINE",t[t.COLON=58]="COLON",t[t.SEMICOLON=59]="SEMICOLON",t[t.LESS_THAN_SIGN=60]="LESS_THAN_SIGN",t[t.EQUALS_SIGN=61]="EQUALS_SIGN",t[t.GREATER_THAN_SIGN=62]="GREATER_THAN_SIGN",t[t.QUESTION_MARK=63]="QUESTION_MARK",t[t.COMMERCIAL_AT=64]="COMMERCIAL_AT",t[t.LATIN_CAPITAL_LETTER_A=65]="LATIN_CAPITAL_LETTER_A",t[t.LATIN_CAPITAL_LETTER_B=66]="LATIN_CAPITAL_LETTER_B",t[t.LATIN_CAPITAL_LETTER_C=67]="LATIN_CAPITAL_LETTER_C",t[t.LATIN_CAPITAL_LETTER_D=68]="LATIN_CAPITAL_LETTER_D",t[t.LATIN_CAPITAL_LETTER_E=69]="LATIN_CAPITAL_LETTER_E",t[t.LATIN_CAPITAL_LETTER_F=70]="LATIN_CAPITAL_LETTER_F",t[t.LATIN_CAPITAL_LETTER_G=71]="LATIN_CAPITAL_LETTER_G",t[t.LATIN_CAPITAL_LETTER_H=72]="LATIN_CAPITAL_LETTER_H",t[t.LATIN_CAPITAL_LETTER_I=73]="LATIN_CAPITAL_LETTER_I",t[t.LATIN_CAPITAL_LETTER_J=74]="LATIN_CAPITAL_LETTER_J",t[t.LATIN_CAPITAL_LETTER_K=75]="LATIN_CAPITAL_LETTER_K",t[t.LATIN_CAPITAL_LETTER_L=76]="LATIN_CAPITAL_LETTER_L",t[t.LATIN_CAPITAL_LETTER_M=77]="LATIN_CAPITAL_LETTER_M",t[t.LATIN_CAPITAL_LETTER_N=78]="LATIN_CAPITAL_LETTER_N",t[t.LATIN_CAPITAL_LETTER_O=79]="LATIN_CAPITAL_LETTER_O",t[t.LATIN_CAPITAL_LETTER_P=80]="LATIN_CAPITAL_LETTER_P",t[t.LATIN_CAPITAL_LETTER_Q=81]="LATIN_CAPITAL_LETTER_Q",t[t.LATIN_CAPITAL_LETTER_R=82]="LATIN_CAPITAL_LETTER_R",t[t.LATIN_CAPITAL_LETTER_S=83]="LATIN_CAPITAL_LETTER_S",t[t.LATIN_CAPITAL_LETTER_T=84]="LATIN_CAPITAL_LETTER_T",t[t.LATIN_CAPITAL_LETTER_U=85]="LATIN_CAPITAL_LETTER_U",t[t.LATIN_CAPITAL_LETTER_V=86]="LATIN_CAPITAL_LETTER_V",t[t.LATIN_CAPITAL_LETTER_W=87]="LATIN_CAPITAL_LETTER_W",t[t.LATIN_CAPITAL_LETTER_X=88]="LATIN_CAPITAL_LETTER_X",t[t.LATIN_CAPITAL_LETTER_Y=89]="LATIN_CAPITAL_LETTER_Y",t[t.LATIN_CAPITAL_LETTER_Z=90]="LATIN_CAPITAL_LETTER_Z",t[t.LEFT_SQUARE_BRACKET=91]="LEFT_SQUARE_BRACKET",t[t.REVERSE_SOLIDUS=92]="REVERSE_SOLIDUS",t[t.RIGHT_SQUARE_BRACKET=93]="RIGHT_SQUARE_BRACKET",t[t.CIRCUMFLEX_ACCENT=94]="CIRCUMFLEX_ACCENT",t[t.LOW_LINE=95]="LOW_LINE",t[t.GRAVE_ACCENT=96]="GRAVE_ACCENT",t[t.LATIN_SMALL_LETTER_A=97]="LATIN_SMALL_LETTER_A",t[t.LATIN_SMALL_LETTER_B=98]="LATIN_SMALL_LETTER_B",t[t.LATIN_SMALL_LETTER_C=99]="LATIN_SMALL_LETTER_C",t[t.LATIN_SMALL_LETTER_D=100]="LATIN_SMALL_LETTER_D",t[t.LATIN_SMALL_LETTER_E=101]="LATIN_SMALL_LETTER_E",t[t.LATIN_SMALL_LETTER_F=102]="LATIN_SMALL_LETTER_F",t[t.LATIN_SMALL_LETTER_G=103]="LATIN_SMALL_LETTER_G",t[t.LATIN_SMALL_LETTER_H=104]="LATIN_SMALL_LETTER_H",t[t.LATIN_SMALL_LETTER_I=105]="LATIN_SMALL_LETTER_I",t[t.LATIN_SMALL_LETTER_J=106]="LATIN_SMALL_LETTER_J",t[t.LATIN_SMALL_LETTER_K=107]="LATIN_SMALL_LETTER_K",t[t.LATIN_SMALL_LETTER_L=108]="LATIN_SMALL_LETTER_L",t[t.LATIN_SMALL_LETTER_M=109]="LATIN_SMALL_LETTER_M",t[t.LATIN_SMALL_LETTER_N=110]="LATIN_SMALL_LETTER_N",t[t.LATIN_SMALL_LETTER_O=111]="LATIN_SMALL_LETTER_O",t[t.LATIN_SMALL_LETTER_P=112]="LATIN_SMALL_LETTER_P",t[t.LATIN_SMALL_LETTER_Q=113]="LATIN_SMALL_LETTER_Q",t[t.LATIN_SMALL_LETTER_R=114]="LATIN_SMALL_LETTER_R",t[t.LATIN_SMALL_LETTER_S=115]="LATIN_SMALL_LETTER_S",t[t.LATIN_SMALL_LETTER_T=116]="LATIN_SMALL_LETTER_T",t[t.LATIN_SMALL_LETTER_U=117]="LATIN_SMALL_LETTER_U",t[t.LATIN_SMALL_LETTER_V=118]="LATIN_SMALL_LETTER_V",t[t.LATIN_SMALL_LETTER_W=119]="LATIN_SMALL_LETTER_W",t[t.LATIN_SMALL_LETTER_X=120]="LATIN_SMALL_LETTER_X",t[t.LATIN_SMALL_LETTER_Y=121]="LATIN_SMALL_LETTER_Y",t[t.LATIN_SMALL_LETTER_Z=122]="LATIN_SMALL_LETTER_Z",t[t.LEFT_CURLY_BRACKET=123]="LEFT_CURLY_BRACKET",t[t.VERTICAL_LINE=124]="VERTICAL_LINE",t[t.RIGHT_CURLY_BRACKET=125]="RIGHT_CURLY_BRACKET",t[t.TILDE=126]="TILDE"})(charset||(charset={}));const escapedSequences={[charset.QUOTATION_MARK]:charset.QUOTATION_MARK,[charset.REVERSE_SOLIDUS]:charset.REVERSE_SOLIDUS,[charset.SOLIDUS]:charset.SOLIDUS,[charset.LATIN_SMALL_LETTER_B]:charset.BACKSPACE,[charset.LATIN_SMALL_LETTER_F]:charset.FORM_FEED,[charset.LATIN_SMALL_LETTER_N]:charset.NEWLINE,[charset.LATIN_SMALL_LETTER_R]:charset.CARRIAGE_RETURN,[charset.LATIN_SMALL_LETTER_T]:charset.TAB};class NonBufferedString{decoder=new TextDecoder("utf-8");string="";byteLength=0;appendChar(e){this.string+=String.fromCharCode(e),this.byteLength+=1}appendBuf(e,r=0,i=e.length){this.string+=this.decoder.decode(e.subarray(r,i)),this.byteLength+=i-r}reset(){this.string="",this.byteLength=0}toString(){return this.string}}class BufferedString{decoder=new TextDecoder("utf-8");buffer;bufferOffset=0;string="";byteLength=0;constructor(e){this.buffer=new Uint8Array(e)}appendChar(e){this.bufferOffset>=this.buffer.length&&this.flushStringBuffer(),this.buffer[this.bufferOffset++]=e,this.byteLength+=1}appendBuf(e,r=0,i=e.length){const s=i-r;this.bufferOffset+s>this.buffer.length&&this.flushStringBuffer(),this.buffer.set(e.subarray(r,i),this.bufferOffset),this.bufferOffset+=s,this.byteLength+=s}flushStringBuffer(){this.string+=this.decoder.decode(this.buffer.subarray(0,this.bufferOffset)),this.bufferOffset=0}reset(){this.string="",this.bufferOffset=0,this.byteLength=0}toString(){return this.flushStringBuffer(),this.string}}var TokenType;(function(t){t[t.LEFT_BRACE=1]="LEFT_BRACE",t[t.RIGHT_BRACE=2]="RIGHT_BRACE",t[t.LEFT_BRACKET=3]="LEFT_BRACKET",t[t.RIGHT_BRACKET=4]="RIGHT_BRACKET",t[t.COLON=5]="COLON",t[t.COMMA=6]="COMMA",t[t.TRUE=7]="TRUE",t[t.FALSE=8]="FALSE",t[t.NULL=9]="NULL",t[t.STRING=10]="STRING",t[t.NUMBER=11]="NUMBER"})(TokenType||(TokenType={}));const{LEFT_BRACE,RIGHT_BRACE,LEFT_BRACKET,RIGHT_BRACKET,COLON,COMMA,TRUE,FALSE,NULL,STRING,NUMBER}=TokenType;var TokenizerStates;(function(t){t[t.START=0]="START",t[t.ENDED=1]="ENDED",t[t.ERROR=2]="ERROR",t[t.TRUE1=3]="TRUE1",t[t.TRUE2=4]="TRUE2",t[t.TRUE3=5]="TRUE3",t[t.FALSE1=6]="FALSE1",t[t.FALSE2=7]="FALSE2",t[t.FALSE3=8]="FALSE3",t[t.FALSE4=9]="FALSE4",t[t.NULL1=10]="NULL1",t[t.NULL2=11]="NULL2",t[t.NULL3=12]="NULL3",t[t.STRING_DEFAULT=13]="STRING_DEFAULT",t[t.STRING_AFTER_BACKSLASH=14]="STRING_AFTER_BACKSLASH",t[t.STRING_UNICODE_DIGIT_1=15]="STRING_UNICODE_DIGIT_1",t[t.STRING_UNICODE_DIGIT_2=16]="STRING_UNICODE_DIGIT_2",t[t.STRING_UNICODE_DIGIT_3=17]="STRING_UNICODE_DIGIT_3",t[t.STRING_UNICODE_DIGIT_4=18]="STRING_UNICODE_DIGIT_4",t[t.STRING_INCOMPLETE_CHAR=19]="STRING_INCOMPLETE_CHAR",t[t.NUMBER_AFTER_INITIAL_MINUS=20]="NUMBER_AFTER_INITIAL_MINUS",t[t.NUMBER_AFTER_INITIAL_ZERO=21]="NUMBER_AFTER_INITIAL_ZERO",t[t.NUMBER_AFTER_INITIAL_NON_ZERO=22]="NUMBER_AFTER_INITIAL_NON_ZERO",t[t.NUMBER_AFTER_FULL_STOP=23]="NUMBER_AFTER_FULL_STOP",t[t.NUMBER_AFTER_DECIMAL=24]="NUMBER_AFTER_DECIMAL",t[t.NUMBER_AFTER_E=25]="NUMBER_AFTER_E",t[t.NUMBER_AFTER_E_AND_SIGN=26]="NUMBER_AFTER_E_AND_SIGN",t[t.NUMBER_AFTER_E_AND_DIGIT=27]="NUMBER_AFTER_E_AND_DIGIT"})(TokenizerStates||(TokenizerStates={}));const defaultOpts={stringBufferSize:0,numberBufferSize:0};class TokenizerError extends Error{constructor(e){super(e);Object.setPrototypeOf(this,TokenizerError.prototype)}}class Tokenizer{state=TokenizerStates.START;bufferedString;bufferedNumber;unicode=void 0;highSurrogate=void 0;bytes_remaining=0;bytes_in_sequence=0;char_split_buffer=new Uint8Array(4);encoder=new TextEncoder;offset=-1;constructor(e){e={...defaultOpts,...e},this.bufferedString=e.stringBufferSize&&e.stringBufferSize>4?new BufferedString(e.stringBufferSize):new NonBufferedString,this.bufferedNumber=e.numberBufferSize&&e.numberBufferSize>0?new BufferedString(e.numberBufferSize):new NonBufferedString}write(e){let r;e instanceof Uint8Array?r=e:typeof e=="string"?r=this.encoder.encode(e):e.buffer||Array.isArray(e)?r=Uint8Array.from(e):this.error(new TypeError("Unexpected type. The `write` function only accepts TypeArrays and Strings."));for(var i=0;i<r.length;i+=1){const s=r[i];switch(this.state){case TokenizerStates.START:if(this.offset+=1,s===charset.SPACE||s===charset.NEWLINE||s===charset.CARRIAGE_RETURN||s===charset.TAB)continue;if(s===charset.LEFT_CURLY_BRACKET){this.onToken(LEFT_BRACE,"{",this.offset);continue}if(s===charset.RIGHT_CURLY_BRACKET){this.onToken(RIGHT_BRACE,"}",this.offset);continue}if(s===charset.LEFT_SQUARE_BRACKET){this.onToken(LEFT_BRACKET,"[",this.offset);continue}if(s===charset.RIGHT_SQUARE_BRACKET){this.onToken(RIGHT_BRACKET,"]",this.offset);continue}if(s===charset.COLON){this.onToken(COLON,":",this.offset);continue}if(s===charset.COMMA){this.onToken(COMMA,",",this.offset);continue}if(s===charset.LATIN_SMALL_LETTER_T){this.state=TokenizerStates.TRUE1;continue}if(s===charset.LATIN_SMALL_LETTER_F){this.state=TokenizerStates.FALSE1;continue}if(s===charset.LATIN_SMALL_LETTER_N){this.state=TokenizerStates.NULL1;continue}if(s===charset.QUOTATION_MARK){this.bufferedString.reset(),this.state=TokenizerStates.STRING_DEFAULT;continue}if(s>=charset.DIGIT_ONE&&s<=charset.DIGIT_NINE){this.bufferedNumber.reset(),this.bufferedNumber.appendChar(s),this.state=TokenizerStates.NUMBER_AFTER_INITIAL_NON_ZERO;continue}if(s===charset.DIGIT_ZERO){this.bufferedNumber.reset(),this.bufferedNumber.appendChar(s),this.state=TokenizerStates.NUMBER_AFTER_INITIAL_ZERO;continue}if(s===charset.HYPHEN_MINUS){this.bufferedNumber.reset(),this.bufferedNumber.appendChar(s),this.state=TokenizerStates.NUMBER_AFTER_INITIAL_MINUS;continue}break;case TokenizerStates.STRING_DEFAULT:if(s===charset.QUOTATION_MARK){const o=this.bufferedString.toString();this.state=TokenizerStates.START,this.onToken(STRING,o,this.offset),this.offset+=this.bufferedString.byteLength+1;continue}if(s===charset.REVERSE_SOLIDUS){this.state=TokenizerStates.STRING_AFTER_BACKSLASH;continue}if(s>=128){if(s>=194&&s<=223?this.bytes_in_sequence=2:s<=239?this.bytes_in_sequence=3:this.bytes_in_sequence=4,this.bytes_in_sequence<=r.length-i){this.bufferedString.appendBuf(r,i,i+this.bytes_in_sequence),i+=this.bytes_in_sequence-1;continue}this.bytes_remaining=i+this.bytes_in_sequence-r.length,this.char_split_buffer.set(r.subarray(i)),i=r.length-1,this.state=TokenizerStates.STRING_INCOMPLETE_CHAR;continue}if(s>=charset.SPACE){this.bufferedString.appendChar(s);continue}break;case TokenizerStates.STRING_INCOMPLETE_CHAR:this.char_split_buffer.set(r.subarray(i,i+this.bytes_remaining),this.bytes_in_sequence-this.bytes_remaining),this.bufferedString.appendBuf(this.char_split_buffer,0,this.bytes_in_sequence),i=this.bytes_remaining-1,this.state=TokenizerStates.STRING_DEFAULT;continue;case TokenizerStates.STRING_AFTER_BACKSLASH:const n=escapedSequences[s];if(n){this.bufferedString.appendChar(n),this.state=TokenizerStates.STRING_DEFAULT;continue}if(s===charset.LATIN_SMALL_LETTER_U){this.unicode="",this.state=TokenizerStates.STRING_UNICODE_DIGIT_1;continue}break;case TokenizerStates.STRING_UNICODE_DIGIT_1:case TokenizerStates.STRING_UNICODE_DIGIT_2:case TokenizerStates.STRING_UNICODE_DIGIT_3:if(s>=charset.DIGIT_ZERO&&s<=charset.DIGIT_NINE||s>=charset.LATIN_CAPITAL_LETTER_A&&s<=charset.LATIN_CAPITAL_LETTER_F||s>=charset.LATIN_SMALL_LETTER_A&&s<=charset.LATIN_SMALL_LETTER_F){this.unicode+=String.fromCharCode(s),this.state+=1;continue}break;case TokenizerStates.STRING_UNICODE_DIGIT_4:if(s>=charset.DIGIT_ZERO&&s<=charset.DIGIT_NINE||s>=charset.LATIN_CAPITAL_LETTER_A&&s<=charset.LATIN_CAPITAL_LETTER_F||s>=charset.LATIN_SMALL_LETTER_A&&s<=charset.LATIN_SMALL_LETTER_F){const o=parseInt(this.unicode+String.fromCharCode(s),16);this.highSurrogate===void 0?o>=55296&&o<=56319?this.highSurrogate=o:this.bufferedString.appendBuf(this.encoder.encode(String.fromCharCode(o))):(o>=56320&&o<=57343?this.bufferedString.appendBuf(this.encoder.encode(String.fromCharCode(this.highSurrogate,o))):this.bufferedString.appendBuf(this.encoder.encode(String.fromCharCode(this.highSurrogate))),this.highSurrogate=void 0),this.state=TokenizerStates.STRING_DEFAULT;continue}case TokenizerStates.NUMBER_AFTER_INITIAL_MINUS:if(s===charset.DIGIT_ZERO){this.bufferedNumber.appendChar(s),this.state=TokenizerStates.NUMBER_AFTER_INITIAL_ZERO;continue}if(s>=charset.DIGIT_ONE&&s<=charset.DIGIT_NINE){this.bufferedNumber.appendChar(s),this.state=TokenizerStates.NUMBER_AFTER_INITIAL_NON_ZERO;continue}break;case TokenizerStates.NUMBER_AFTER_INITIAL_ZERO:if(s===charset.FULL_STOP){this.bufferedNumber.appendChar(s),this.state=TokenizerStates.NUMBER_AFTER_FULL_STOP;continue}if(s===charset.LATIN_SMALL_LETTER_E||s===charset.LATIN_CAPITAL_LETTER_E){this.bufferedNumber.appendChar(s),this.state=TokenizerStates.NUMBER_AFTER_E;continue}i-=1,this.state=TokenizerStates.START,this.emitNumber();continue;case TokenizerStates.NUMBER_AFTER_INITIAL_NON_ZERO:if(s>=charset.DIGIT_ZERO&&s<=charset.DIGIT_NINE){this.bufferedNumber.appendChar(s);continue}if(s===charset.FULL_STOP){this.bufferedNumber.appendChar(s),this.state=TokenizerStates.NUMBER_AFTER_FULL_STOP;continue}if(s===charset.LATIN_SMALL_LETTER_E||s===charset.LATIN_CAPITAL_LETTER_E){this.bufferedNumber.appendChar(s),this.state=TokenizerStates.NUMBER_AFTER_E;continue}i-=1,this.state=TokenizerStates.START,this.emitNumber();continue;case TokenizerStates.NUMBER_AFTER_FULL_STOP:if(s>=charset.DIGIT_ZERO&&s<=charset.DIGIT_NINE){this.bufferedNumber.appendChar(s),this.state=TokenizerStates.NUMBER_AFTER_DECIMAL;continue}break;case TokenizerStates.NUMBER_AFTER_DECIMAL:if(s>=charset.DIGIT_ZERO&&s<=charset.DIGIT_NINE){this.bufferedNumber.appendChar(s);continue}if(s===charset.LATIN_SMALL_LETTER_E||s===charset.LATIN_CAPITAL_LETTER_E){this.bufferedNumber.appendChar(s),this.state=TokenizerStates.NUMBER_AFTER_E;continue}i-=1,this.state=TokenizerStates.START,this.emitNumber();continue;case TokenizerStates.NUMBER_AFTER_E:if(s===charset.PLUS_SIGN||s===charset.HYPHEN_MINUS){this.bufferedNumber.appendChar(s),this.state=TokenizerStates.NUMBER_AFTER_E_AND_SIGN;continue}case TokenizerStates.NUMBER_AFTER_E_AND_SIGN:if(s>=charset.DIGIT_ZERO&&s<=charset.DIGIT_NINE){this.bufferedNumber.appendChar(s),this.state=TokenizerStates.NUMBER_AFTER_E_AND_DIGIT;continue}break;case TokenizerStates.NUMBER_AFTER_E_AND_DIGIT:if(s>=charset.DIGIT_ZERO&&s<=charset.DIGIT_NINE){this.bufferedNumber.appendChar(s);continue}i-=1,this.state=TokenizerStates.START,this.emitNumber();continue;case TokenizerStates.TRUE1:if(s===charset.LATIN_SMALL_LETTER_R){this.state=TokenizerStates.TRUE2;continue}break;case TokenizerStates.TRUE2:if(s===charset.LATIN_SMALL_LETTER_U){this.state=TokenizerStates.TRUE3;continue}break;case TokenizerStates.TRUE3:if(s===charset.LATIN_SMALL_LETTER_E){this.state=TokenizerStates.START,this.onToken(TRUE,!0,this.offset),this.offset+=3;continue}break;case TokenizerStates.FALSE1:if(s===charset.LATIN_SMALL_LETTER_A){this.state=TokenizerStates.FALSE2;continue}break;case TokenizerStates.FALSE2:if(s===charset.LATIN_SMALL_LETTER_L){this.state=TokenizerStates.FALSE3;continue}break;case TokenizerStates.FALSE3:if(s===charset.LATIN_SMALL_LETTER_S){this.state=TokenizerStates.FALSE4;continue}break;case TokenizerStates.FALSE4:if(s===charset.LATIN_SMALL_LETTER_E){this.state=TokenizerStates.START,this.onToken(FALSE,!1,this.offset),this.offset+=4;continue}break;case TokenizerStates.NULL1:if(s===charset.LATIN_SMALL_LETTER_U){this.state=TokenizerStates.NULL2;continue}break;case TokenizerStates.NULL2:if(s===charset.LATIN_SMALL_LETTER_L){this.state=TokenizerStates.NULL3;continue}break;case TokenizerStates.NULL3:if(s===charset.LATIN_SMALL_LETTER_L){this.state=TokenizerStates.START,this.onToken(NULL,null,this.offset),this.offset+=3;continue}break}this.error(new TokenizerError(`Unexpected "${String.fromCharCode(s)}" at position "${i}" in state ${TokenizerStates[this.state]}`))}}emitNumber(){this.onToken(NUMBER,this.parseNumber(this.bufferedNumber.toString()),this.offset),this.offset+=this.bufferedNumber.byteLength-1}parseNumber(e){return Number(e)}error(e){throw this.state=TokenizerStates.ERROR,e}end(){this.state!==TokenizerStates.START&&this.error(new TokenizerError(`Tokenizer ended in the middle of a token (state: ${TokenizerStates[this.state]}). Either not all the data was received or the data was invalid.`)),this.state=TokenizerStates.ENDED}onToken(e,r,i){}}const{LEFT_BRACE:LEFT_BRACE1,RIGHT_BRACE:RIGHT_BRACE1,LEFT_BRACKET:LEFT_BRACKET1,RIGHT_BRACKET:RIGHT_BRACKET1,COLON:COLON1,COMMA:COMMA1,TRUE:TRUE1,FALSE:FALSE1,NULL:NULL1,STRING:STRING1,NUMBER:NUMBER1}=TokenType;var ParserState;(function(t){t[t.VALUE=0]="VALUE",t[t.KEY=1]="KEY",t[t.COLON=2]="COLON",t[t.COMMA=3]="COMMA",t[t.ENDED=4]="ENDED",t[t.ERROR=5]="ERROR"})(ParserState||(ParserState={}));var ParserMode;(function(t){t[t.OBJECT=0]="OBJECT",t[t.ARRAY=1]="ARRAY"})(ParserMode||(ParserMode={}));const defaultOpts1={paths:void 0,keepStack:!0};class TokenParserError extends Error{constructor(e){super(e);Object.setPrototypeOf(this,TokenParserError.prototype)}}class Parser{paths;keepStack;state=ParserState.VALUE;mode=void 0;key=void 0;value=void 0;stack=[];constructor(e){e={...defaultOpts1,...e},e.paths&&(this.paths=e.paths.map(r=>{if(r===void 0||r==="$*")return;if(!r.startsWith("$"))throw new TokenParserError(`Invalid selector "${r}". Should start with "$".`);const i=r.split(".").slice(1);if(i.includes(""))throw new TokenParserError(`Invalid selector "${r}". ".." syntax not supported.`);return i})),this.keepStack=e.keepStack}shouldEmit(){return this.paths?this.paths.some(e=>{if(e===void 0)return!0;if(e.length!==this.stack.length)return!1;for(let i=0;i<e.length-1;i++){const s=e[i],n=this.stack[i+1].key;if(s!=="*"&&s!==n)return!1}const r=e[e.length-1];return r==="*"?!0:r===this.key?.toString()}):!0}push(){this.stack.push({key:this.key,value:this.value,mode:this.mode,emit:this.shouldEmit()})}pop(){const e=this.value;let r;({key:this.key,value:this.value,mode:this.mode,emit:r}=this.stack.pop()),this.emit(e,r),this.state=this.mode!==void 0?ParserState.COMMA:ParserState.VALUE}emit(e,r){this.value&&!this.keepStack&&this.stack.every(i=>!i.emit)&&delete this.value[this.key],r&&this.onValue(e,this.key,this.value,this.stack)}write(e,r){if(this.state===ParserState.VALUE){if(e===STRING1||e===NUMBER1||e===TRUE1||e===FALSE1||e===NULL1){this.mode===ParserMode.OBJECT?(this.value[this.key]=r,this.state=ParserState.COMMA):this.mode===ParserMode.ARRAY&&(this.value.push(r),this.state=ParserState.COMMA),this.emit(r,this.shouldEmit());return}if(e===LEFT_BRACE1){if(this.push(),this.mode===ParserMode.OBJECT)this.value=this.value[this.key]={};else if(this.mode===ParserMode.ARRAY){const i={};this.value.push(i),this.value=i}else this.value={};this.mode=ParserMode.OBJECT,this.state=ParserState.KEY,this.key=void 0;return}if(e===LEFT_BRACKET1){if(this.push(),this.mode===ParserMode.OBJECT)this.value=this.value[this.key]=[];else if(this.mode===ParserMode.ARRAY){const i=[];this.value.push(i),this.value=i}else this.value=[];this.mode=ParserMode.ARRAY,this.state=ParserState.VALUE,this.key=0;return}if(this.mode===ParserMode.ARRAY&&e===RIGHT_BRACKET1&&this.value.length===0){this.pop();return}}if(this.state===ParserState.KEY){if(e===STRING1){this.key=r,this.state=ParserState.COLON;return}if(e===RIGHT_BRACE1&&Object.keys(this.value).length===0){this.pop();return}}if(this.state===ParserState.COLON&&e===COLON1){this.state=ParserState.VALUE;return}if(this.state===ParserState.COMMA){if(e===COMMA1){if(this.mode===ParserMode.ARRAY){this.state=ParserState.VALUE,this.key+=1;return}if(this.mode===ParserMode.OBJECT){this.state=ParserState.KEY;return}}if(e===RIGHT_BRACE1&&this.mode===ParserMode.OBJECT||e===RIGHT_BRACKET1&&this.mode===ParserMode.ARRAY){this.pop();return}}this.error(new TokenParserError(`Unexpected ${TokenType[e]} (${JSON.stringify(r)}) in state ${ParserState[this.state]}`))}error(e){throw this.state=ParserState.ERROR,e}end(){(this.state!==ParserState.VALUE||this.stack.length>0)&&this.error(new TokenParserError(`Parser ended in mid-parsing (state: ${ParserState[this.state]}). Either not all the data was received or the data was invalid.`)),this.state=ParserState.ENDED}onValue(e,r,i,s){}}class JSONParser{tokenizer;parser;constructor(e={}){this.tokenizer=new Tokenizer(e),this.parser=new Parser(e),this.tokenizer.onToken=this.parser.write.bind(this.parser)}write(e){try{this.tokenizer.write(e)}catch(r){throw r instanceof TokenParserError&&this.tokenizer.error(r),r}}set onToken(e){this.tokenizer.onToken=e}set onValue(e){this.parser.onValue=e}end(){this.parser.end(),this.tokenizer.end()}}function isMessage(t){return Array.isArray(t)&&t.length===2&&typeof t[0]=="number"&&typeof t[1]!="undefined"}class Indexer1{#e;#t;constructor(e){if(e!=null&&e<2)throw new Error(`The attribute 'max' must be greater than 1 but ${e} has specified`);this.#e=e??Number.MAX_SAFE_INTEGER,this.#t=-1}next(){return this.#t>=this.#e&&(this.#t=-1),this.#t+=1,this.#t}}class TimeoutError1 extends Error{constructor(){super("the process didn't complete in time");this.name="TimeoutError"}}class ResponseWaiter1{#e;#t;constructor(e=1e4){this.#e=new Map,this.#t=e}get waiterCount(){return this.#e.size}wait(e,r){let i=this.#e.get(e)?.response;if(!i){i=deferred3();const s=setTimeout(()=>{const n=this.#e.get(e)?.response;!n||(n.reject(new TimeoutError1),this.#e.delete(e))},r??this.#t);this.#e.set(e,{timer:s,response:i})}return i}provide(e){const[r,i]=e,s=this.#e.get(r);if(!s)return!1;this.#e.delete(r);const{timer:n,response:o}=s;return clearTimeout(n),o.resolve(e),!0}}const MSGID_THRESHOLD1=2**32,BUFFER_SIZE=32*1024,utf8Encoder=new TextEncoder;class Session1{#e;#t;#i;#r;#n;#o;#s;#a;constructor(e,r,i=()=>{},s={}){this.#e=new Indexer1(MSGID_THRESHOLD1),this.#t=new ResponseWaiter1(s.responseTimeout),this.#i=e,this.#r=r,this.#n=i,this.#s=!1,this.#a=deferred3(),this.#o=this.listen().catch(n=>{s.errorCallback?s.errorCallback(n):console.error(`Unexpected error occured in session: ${n}`)})}nextMsgid(){return this.#e.next()*-1}async send(e){await mod4.writeAll(this.#r,utf8Encoder.encode(JSON.stringify(e)))}async listen(){const e=new JSONParser;e.onValue=(r,i,s,n)=>{if(!(n.length>0)){if(!isMessage(r)){console.warn(`Unexpected data received: ${r}`);return}if(!this.#t.provide(r)){this.#n.apply(this,[r]);return}}};try{const r=new Uint8Array(BUFFER_SIZE);for(;!this.#s;){const i=await Promise.race([this.#a,this.#i.read(r)]);if(i==null)break;e.write(r.subarray(0,i))}}catch(r){if(r instanceof SessionClosedError1||r instanceof Deno.errors.BadResource)return;throw r}}dispose(){this.close()}close(){this.#s=!0,this.#a.reject(new SessionClosedError1)}waitClosed(){return this.#o}async reply(e,r){if(this.#s)throw new SessionClosedError1;const i=[e,r];await this.send(i)}async redraw(e=!1){if(this.#s)throw new SessionClosedError1;const r=["redraw",e?"force":""];await this.send(r)}async ex(e){if(this.#s)throw new SessionClosedError1;const r=["ex",e];await this.send(r)}async normal(e){if(this.#s)throw new SessionClosedError1;const r=["normal",e];await this.send(r)}async expr(e){if(this.#s)throw new SessionClosedError1;const r=this.nextMsgid(),i=["expr",e,r],[s,n]=await Promise.all([this.send(i),this.#t.wait(r)]);return n[1]}async exprNoReply(e){if(this.#s)throw new SessionClosedError1;const r=["expr",e];await this.send(r)}async call(e,...r){if(this.#s)throw new SessionClosedError1;const i=this.nextMsgid(),s=["call",e,r,i],[n,o]=await Promise.all([this.send(s),this.#t.wait(i)]);return o[1]}async callNoReply(e,...r){if(this.#s)throw new SessionClosedError1;const i=["call",e,r];await this.send(i)}replaceCallback(e){this.#n=e}}class SessionClosedError1 extends Error{constructor(){super("The session is closed");this.name="SessionClosedError"}}async function using(t,e){try{return await e(t)}finally{await t.dispose()}}const responseTimeout=60*60*24*7;class Invoker{#e;constructor(e){this.#e=e}register(e,r,i,s){this.#e.register(e,r,i,s)}dispatch(e,r,i){return this.#e.dispatch(e,r,i)}dispatchAsync(e,r,i,s,n){return this.#e.dispatch(e,r,i).then(async o=>{try{await this.#e.call("denops#callback#call",s,o)}catch(a){console.error(`${a.stack??a.toString()}`)}}).catch(async o=>{try{await this.#e.call("denops#callback#call",n,toErrorObject(o))}catch(a){console.error(`${a.stack??a.toString()}`)}}),Promise.resolve()}}function isInvokerMethod(t){return t in Invoker.prototype}function toErrorObject(t){return t instanceof Error?{name:t.name,message:t.message,stack:t.stack}:{name:typeof t,message:`${t}`}}const importMeta={url:"file:///Users/alisue/ghq/github.com/vim-denops/denops.vim/denops/@denops-private/service.ts",main:!1},workerScript="./worker/script.bundle.js";class Service{#e;#t;constructor(e){this.#e=new Map,this.#t=e,this.#t.register(new Invoker(this))}register(e,r,i,s){const n=this.#e.get(e);if(n)if(s.mode==="reload")i.mode==="debug"&&console.log(`A denops plugin '${e}' is already registered. Reload`),n.worker.terminate();else if(s.mode==="skip"){i.mode==="debug"&&console.log(`A denops plugin '${e}' is already registered. Skip`);return}else throw new Error(`A denops plugin '${e}' is already registered`);const o=new Worker(new URL(workerScript,importMeta.url).href,{name:e,type:"module",deno:{namespace:!0}});o.postMessage({name:e,script:r,meta:i});const a=new WorkerReader(o),h=new WorkerWriter(o),l=new Session(a,h,{call:async(c,...f)=>(ensureString(c),ensureArray(f),await this.call(c,...f)),batch:async(...c)=>(ensureArray(c,u=>isArray(u)&&u.length>0&&isString(u[0])),await this.batch(...c)),dispatch:async(c,f,...u)=>(ensureString(c),ensureString(f),ensureArray(u),await this.dispatch(c,f,u))},{responseTimeout});this.#e.set(e,{session:l,worker:o})}async call(e,...r){return await this.#t.call(e,...r)}async batch(...e){return await this.#t.batch(...e)}async dispatch(e,r,i){try{const s=this.#e.get(e);if(!s)throw new Error(`No plugin '${e}' is registered`);return await s.session.call(r,...i)}catch(s){throw`${s.stack??s.toString()}`}}waitClosed(){return this.#t.waitClosed()}}class Vim{#e;constructor(e,r){this.#e=new Session1(e,r,void 0,{responseTimeout})}async call(e,...r){const[i,s]=await this.#e.call("denops#api#vim#call",e,r);if(s!=="")throw new Error(`Failed to call '${e}(${r.join(", ")})': ${s}`);return i}async batch(...e){return await this.#e.call("denops#api#vim#batch",e)}register(e){this.#e.replaceCallback(async r=>{const[i,s]=r;let n=null,o=null;try{n=await dispatch(e,s)}catch(a){o=a}i!==0?await this.#e.reply(i,[n,o]):o!==null&&console.error(o)})}waitClosed(){return this.#e.waitClosed()}dispose(){this.#e.dispose()}}async function dispatch(t,e){if(isInvokeMessage(e)){const[r,i,s]=e;if(!isInvokerMethod(i))throw new Error(`Method '${i}' is not defined in the invoker`);return await t[i](...s)}else throw new Error(`Unexpected JSON channel message is received: ${JSON.stringify(e)}`)}function isInvokeMessage(t){return Array.isArray(t)&&t.length===3&&t[0]==="invoke"&&typeof t[1]=="string"&&Array.isArray(t[2])}class Neovim{#e;constructor(e,r){this.#e=new Session(e,r,void 0,{responseTimeout})}call(e,...r){return this.#e.call("nvim_call_function",e,r)}async batch(...e){const[r,i]=await this.#e.call("nvim_call_atomic",e.map(([s,...n])=>["nvim_call_function",[s,n]]));return i?[r,i[2]]:[r,""]}register(e){this.#e.dispatcher={async invoke(r,i){if(ensureString(r),ensureArray(i),!isInvokerMethod(r))throw new Error(`Method '${r}' is not defined in the invoker`);return await e[r](...i)}}}waitClosed(){return this.#e.waitClosed()}dispose(){this.#e.dispose()}}const textDecoder=new TextDecoder;class TraceReader{#e;constructor(e){this.#e=e}close(){this.#e.close()}async read(e){const r=await this.#e.read(e);if(r){const i=e.subarray(0,r);try{console.log("r:",textDecoder.decode(i))}catch{console.log("r:",i)}}return r}}class TraceWriter{#e;constructor(e){this.#e=e}async write(e){const r=await this.#e.write(e),i=e.subarray(0,r);try{console.log("w:",textDecoder.decode(i))}catch{console.log("w:",i)}return r}}const opts=mod.parse(Deno.args);if(!opts.mode)throw new Error("No `--mode` option is specified.");const listener=Deno.listen({hostname:"127.0.0.1",port:0}),addr=listener.addr;console.log(`${addr.hostname}:${addr.port}`);for await(const t of listener){const e=opts.trace?new TraceReader(t):t,r=opts.trace?new TraceWriter(t):t,i=opts.mode==="vim"?Vim:Neovim;await using(new i(e,r),async s=>{await new Service(s).waitClosed()});break}
